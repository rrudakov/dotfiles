#+TITLE: My Emacs configuration
#+AUTHOR: Roman Rudakov
#+EMAIL: rrudakov@pm.me
#+STARTUP: fold

[[https://www.gnu.org/software/emacs/][https://img.shields.io/badge/GNU%20Emacs-27.1-b1.svg]]
[[https://orgmode.org/][https://img.shields.io/badge/org--mode-9.3.8-elpalus.svg]]

This file is my literate config for [[https://www.gnu.org/software/emacs/][GNU/Emacs]] written using [[https://orgmode.org/][org-mode]] syntax and
tangle automatically to emacs lisp file which loaded from ~.emacs.d/init.el~.

* Keybindings help

This section is just some kind of reference card where I keep all the
keybindings which I find useful and probably will use.

** Common

I already use this commands on the daily basis and don't need to memorize them
but I'll keep it here for history.

| Command                   | Keybinding | Description                                                               |
|---------------------------+------------+---------------------------------------------------------------------------|
| ~eval-expression~         | ~M-:~      | Evaluate any emacs lisp expression and print the result in the minibuffer |
| ~delete-horizontal-space~ | ~M-\~      | Delete all white spaces between two symbols                               |
| ~delete-blank-lines~      | ~C-x C-o~  | Delete all empty lines below the pointer                                  |

** Haskell

I used to write some code in Haskell. Hereby some keybindings for haskell-mode.

| Keybinding | Description                                                                                                              |
|------------+--------------------------------------------------------------------------------------------------------------------------|
| ~C-M-\~    | Reformat the current region                                                                                              |
| ~M-q~      | Reformat the current declaration. When inside a comment, it fills the current paragraph instead, like the standard ~M-q~ |

** Org-mode

Org-mode has a lot of functionality and sometimes it's almost impossible to
remember all the keybindings and commands. I'll keep here all useful commands
which I can use in the org-mode buffers.

| Keybinding    | Description                                                                  |
|---------------+------------------------------------------------------------------------------|
| ~C-c ^~       | Sort headlines                                                               |
| ~C-c /~       | Prompt to make sparse-tree                                                   |
| ~C-c C-x f~   | Footnote action command                                                      |
| ~C-c C-c~     | When at footnote, go to definition. When at definition, go back to reference |
| ~M-S-<right>~ | Insert new table column                                                      |
| ~C-c +~       | Sum all numbers in the current column                                        |
| ~C-c C-x p~   | Insert property                                                              |
| ~C-c C-x C-d~ | Display time summaries for each sub-tree in the current buffer               |

Besides standard keybindings I use [[https://orgmode.org/manual/Speed-Keys.html][speed-keys]]. Speed keys can be enabled by
setting ~org-use-speed-keys~ to ~t~. When the point at the first symbol of the
headline I can execute some commands with only one key press.

| Key       | Description                         |
|-----------+-------------------------------------|
| ~I~       | Start clock                         |
| ~O~       | Stop clock                          |
| ~w~       | Refile current headline             |
| ~a~       | Archive current sub-tree            |
| ~0/1/2/3~ | Set priority to corresponding value |

There are more speed commands. All available commands can be found in the help
buffer when you press ~?~ on any headline.

*** Agenda view

In the agenda view all standard commands have different keybindings, because
it's read-only buffer and you can navigate and execute commands with a single
key press.

| Key       | Description                                                                          |
|-----------+--------------------------------------------------------------------------------------|
| ~p~       | Previous period (in month-view it's previous month, in week-view it's previous week) |
| ~n~       | Next period                                                                          |
| ~.~       | Quickly jump to today                                                                |
| ~F~       | Follow mode (corresponding headlines will be shown in the separate buffer)           |
| ~<space>~ | Open org-mode file with corresponding headline in the separate buffer                |

** Highlight text in buffer (hi-lock-mode)

This is useful when you want to highlight some parts of long text with
different colors to distinguish them from the rest of buffer content.

| Command                           | Keybinding | Description                                                                            |
|-----------------------------------+------------+----------------------------------------------------------------------------------------|
| ~highlight-regexp~                | ~M-s h r~  | Highlight by regex with given face (regex and face are prompted using completing read) |
| ~unhighlight-regexp~              | ~M-s h u~  | Remove highlighting for regex (Regex will be prompted using completing read)           |
| ~highlight-phrase~                | ~M-s h p~  | Highlight phrase (case insensitive) with given text                                    |
| ~highlight-lines-matching-regexp~ | ~M-s h l~  | Highlight the entire line which contains given phrase                                  |

** Helm

I use [[https://github.com/emacs-helm/helm][helm]] for incremental completion. It has a lot of modules and
extensions. Here I'll keep useful keybindings for them.

| Keybinding | Description                                                                                                    |
|------------+----------------------------------------------------------------------------------------------------------------|
| ~C-c i~    | Insert file path at point to current buffer (works also in minibuffer if ~enable-recursive-minibuffer~ is ~t~) |
| ~C-x c s~  | Search using surfraw utility on the web (surfraw must be installed system-wide)                                |

** Dired

Very powerful file manager inside of Emacs.

| Command      | Keybinding | Description                             |
|--------------+------------+-----------------------------------------|
| ~dired-jump~ | ~C-x C-j~  | Jump to directory of the current buffer |

* External configuration example

** Define databases connections

Actually this section is obsolete. I don't use ~ejc-sql~ in favor of ~org-mode~
with ~org-babel~. So far it's enough for my needs. This example here is for
~ejc-sql~ package and just shows how I used to use it.

#+begin_src emacs-lisp :tangle no
(require 'cl-lib)
(require 'ejc-sql)

(cl-defun rr/create-postgres-connection (name &key hostname dbname username password)
  "Defun postgresql connection with given NAME for ejc package.

Required information is HOSTNAME, DBNAME, USERNAME and PASSWORD"
  (ejc-create-connection
   name
   :classpath "/home/rrudakov/.m2/repository/org/postgresql/postgresql/42.2.5/postgresql-42.2.5.jar"
   :dbtype "postgresql"
   :dbname dbname
   :host hostname
   :port "5432"
   :user username
   :password password))

;; Define connections
(defun rr/setup-connections ()
  "Setup all database connections."
  (progn
    (rr/create-postgres-connection
     "Connection_name"
     :hostname "localhost"
     :dbname "database_name"
     :username "username"
     :password "password")
    ))

(provide 'databases)
#+end_src

* Syntax help

** Org-mode

*** Lists

To create unordered list in the org-mode documents just start line from one of
the following symbols: ~-~, ~+~ or ~*~ (start not recommended, because it will
be ambiguous)

Ordered list starts from either ~1.~ or ~1)~. This can be customized.

Unordered lists with separator ~::~ will produce description lists.

All lists can be nested in any order.

* Useful functions

** Capitalize first char

Don't remember why I have it. Probably it can be deprecated in favor to
~capitalize-word~ function which built-in into emacs.

#+begin_src emacs-lisp
(defun rr/capitalize-first-char (&optional string)
  "Capitalize only the first character of the input STRING."
  (when (and string (> (length string) 0))
    (let ((first-char (substring string nil 1))
          (rest-str   (substring string 1)))
      (concat (capitalize first-char) rest-str))))
#+end_src

** Replace org-link with description of if empty its address

This is useful function has some kind of /unlink/ behavior. It replaces org
link with it's description or if there is no description with its address.

#+begin_src emacs-lisp
(defun rr/org-replace-link-by-link-description ()
  "Replace an org link by its description or if empty its address."
  (interactive)
  (if (org-in-regexp org-bracket-link-regexp 1)
      (save-excursion
        (let ((remove (list (match-beginning 0) (match-end 0)))
              (description (if (match-end 3)
                               (org-match-string-no-properties 3)
                             (org-match-string-no-properties 1))))
          (apply 'delete-region remove)
          (insert description)))))
#+end_src

** Smart toggle flycheck error list window

Was written a long time ago. Used to use it to pop-up
~flycheck-error-list-buffer~ if it was opened before or create new one. Now I'm
using [[https://github.com/yasuyk/helm-flycheck][helm-flycheck]]. Maybe someone will find it useful.

#+begin_src emacs-lisp
(defun rr/flycheck-list-smart-toggle ()
  "Toggle flycheck error list buffer."
  (interactive)
  (if (equal (buffer-name) flycheck-error-list-buffer)
      (quit-window)
    (if (member flycheck-error-list-buffer
                (mapcar 'buffer-name
                        (mapcar 'window-buffer (window-list))))
        (dolist (window (window-list))
          (when (equal flycheck-error-list-buffer
                       (buffer-name (window-buffer window)))
            (quit-window t window)))
      (flycheck-list-errors))))
#+end_src

** Update vc-state in all buffers

Used as ~magit-post-refresh-hook~ to update ~vc-state~ for each opened
buffer. It will affect all modes which relies on ~vc-mode~ state (for example
~vc-status~ in the modeline and [[https://github.com/dgutov/diff-hl][diff-hl]]).

#+begin_src emacs-lisp
(defun rr/refresh-vc-state ()
  "Refresh `vc-state' on all buffers."
  (dolist (buff (buffer-list))
    (with-current-buffer buff
      (when (vc-mode)
        (vc-refresh-state)))))
#+end_src

** Reset font-lock for all org-mode buffers

I use emacs-server which starts in the background using systemd. Also I use
org-mode option ~org-clock-persist~ set to ~t~ which force emacs to open last
org file with clocking headline. The theme applies after first frame is created
and I can see leading stars in the org file which was opened before applying
theme. This function is used to use for fix this behavior.

After I switch to [[https://gitlab.com/protesilaos/modus-themes][modus-themes]] looks like the issue is gone. I'll keep this
function in case this behavior will appear again.

#+begin_src emacs-lisp
(defun rr/refresh-org-buffers ()
  "Reset font-lock on all org-mode buffers."
  (dolist (buff (buffer-list))
    (with-current-buffer buff
      (when (eq major-mode 'org-mode)
        (normal-mode)))))
#+end_src

** Prefer split windows side-by-side

Separate function to force emacs to split windows side by side if possible.

#+begin_src emacs-lisp
(defun split-window-prefer-side-by-side (&optional window)
  (let ((split-height-threshold (and (< (window-width window)
                                        split-width-threshold)
                                     split-height-threshold)))
    (split-window-sensibly window)))
#+end_src

** Set margins

For major modes derived from ~text-mode~ I prefer to have some margins. This
function set margins buffer locally. I use it in ~markdown-mode-hook~ and
~org-mode-hook~.

#+begin_src emacs-lisp
(defun rr/set-margins ()
  "Set margins in current buffer."
  (setq left-margin-width 3)
  (setq right-margin-width 3))
#+end_src

** Copy file name to clipboard

Useful function to copy current buffer file path to clipboard. Works in regular
emacs buffers and in dired mode.

#+begin_src emacs-lisp
(defun prelude-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

** Make SVG screenshot of emacs

Stolen from [[https://www.reddit.com/r/emacs/comments/idz35e/emacs_27_can_take_svg_screenshots_of_itself/][reddit]]. Emacs should be built with cairo support.

#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((filename (make-temp-file "Emacs" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))
#+end_src

* Variables

** Define variables for save file and backup directory

I prefer to keep my ~.emacs.d~ as clean as possible. One of the options is to
keep all backup files and temporary files in the separate directory. Here I
define variables for this purpose.

#+begin_src emacs-lisp
(defconst rr-savefile-dir (expand-file-name "savefile" user-emacs-directory)
  "Declare variable for save file directory.")

(defconst rr-backup-dir (expand-file-name "backup" user-emacs-directory)
  "Declare variable for all backup files.")
#+end_src

** Define keymap for LSP-mode

I don't want to use default ~lsp-mode~ keybindings. All I need is a few of
them and I want to keep all under my control. Here I define custom keymap to
bind all useful lsp commands later.

#+begin_src emacs-lisp
(defvar rr-lsp-keymap
  (make-sparse-keymap)
  "My personal keymap for LSP mode.")
#+end_src

** Load my secret tokens

All sensitive information which cannot be stored in the ~.authinfo.gpg~ I'm
going to define in the separate emacs-lisp module which I won't keep under the
version control. If this module doesn't exist (for example on the fresh
installation or new machine) just ignore it. It's probably not the best way to
keep passwords and tokens and I should consider moving to [[https://www.passwordstore.org][password-store]] or
similar tools.

I already have some packages for interacting with password-store and I don't
have ~mysecret.el~ on my machines. Probably this will be removed in the
future.

#+begin_src emacs-lisp
(require 'mysecret nil t)
#+end_src

* Emacs built-in tweaks

Emacs provides a lot of useful customization out of the box. I use [[https://github.com/jwiegley/use-package][use-package]]
to keep my config clean and declarative. It's possible to declare customization
for built-in modules as well with use-package. I set
~use-package-always-ensure~ to ~t~ to automatically install packages from MELPA
if it's not installed yet. For build-in packages option ~:ensure nil~ should be
used to prevent attempt to install it from MELPA.

** Unset some unused keybindings

I find some keybindings not useful. ~C-z~ is freezing emacs GUI or something
like this. I don't know what is it for and I don't think I will be use it. All
such keybindings I'm going to unset to map them to something I really need.

#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+end_src

** Emacs core variables

Part of the Emacs is written in C language and some crucial variables defined
in C files but it's still possible to update them. Here is the list of such
settings.

*** Use UTF-8 as default coding system

Stolen from doom-emacs. Use UTF-8 for everything.

#+begin_src emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system        'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(setq locale-coding-system   'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
#+end_src

*** Disable bidirectional text rendering

Emacs support rendering text for some languages which should be written from
right to left (for example Arabic), but this feature slows down emacs a little
bit, so I disable it globally.

#+begin_src emacs-lisp
(setq bidi-inhibit-bpa t)
(setq-default bidi-paragraph-direction 'left-to-right)
#+end_src

*** Enable y/n answers instead of yes/no

Not really variable assignment or configuration change, but this is kind of
core functionality. As [[https://www.emacswiki.org/emacs/YesOrNoP][emacs-wiki]] said ~yes-or-no-p~ is for more important
questions but I didn't have problem with just single symbol function ~y-or-n-p~
so I'm creating the alias and forget about it.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Increase amount of data which emacs reads from the process

This is recommended setting to increase ~lsp-mode~ performance. Increase the
amount of data which Emacs reads from the process. Default (4k) is too low
considering that the some of the language server responses are in 800k - 3M
range.

#+begin_src emacs-lisp
(setq read-process-output-max (* 4 1024 1024))
#+end_src

*** Increase max number of Lisp variable bindings

Limit on number of Lisp variable bindings and ~unwind-protects~.
If Lisp code tries to increase the total number past this amount,
an error is signaled.

#+begin_src emacs-lisp
(setq max-specpdl-size 3200)
#+end_src

*** Do not show auto save messages in the minibuffer

If autosave is enabled do not print annoying message to the minibuffer every
time the file saved.

#+begin_src emacs-lisp
(setq auto-save-no-message t)
#+end_src

*** Avoid creating lock files

I don't see any profits from the lock files, so I don't want emacs to create them.

#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src

*** Set tab width

Distance between tab stops (for display of tab characters), in columns. Affects
to ~lsp-java~ directly and set indentation size for ~newline-and-indent~
function. I use [[https://github.com/google/google-java-format][google-java-format]] which uses 2 spaces by default for
indentation so I set this setting to ~2~.

#+begin_src emacs-lisp
(setq-default tab-width 2)
#+end_src

*** COMMENT Set default margins

Flycheck has an option to display indicators in margins instead of fringes. By
default margin sizes is 0 which means they are invisible. To be able to use
margin flycheck indicators I have to set margins to at least ~1~.

#+begin_src emacs-lisp
(setq-default left-margin-width 1)
(setq-default right-margin-width 1)
#+end_src

*** Prefer newer files to load

When use ~load~ function always prefer the latest version of a file.

#+begin_src emacs-lisp
(setq load-prefer-newer t)
#+end_src

*** Avoid tabs

Holy war tabs vs spaces :)

I prefer spaces, so disable tabs globally.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

*** Buffer settings, fringes and indicators

To display fringes on the edge of emacs frame I need to set this setting to
~t~. If I set this to ~nil~ fringes will be displayed between margins and
buffer content.

#+begin_src emacs-lisp
(setq-default fringes-outside-margins t)
#+end_src

Disable distracting indicators in the left fringe for empty lines.

#+begin_src emacs-lisp
(setq-default indicate-empty-lines nil)
#+end_src

Hide cursor in non-selected windows.

#+begin_src emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

One more distraction is continuation arrows in the fringes. Disable it.

#+begin_src emacs-lisp
(setq-default fringe-indicator-alist
              (delq (assq 'continuation fringe-indicator-alist)
                    fringe-indicator-alist))
#+end_src

Disable visual indication of buffer boundaries and scrolling.

#+begin_src emacs-lisp
(setq-default indicate-buffer-boundaries nil)
#+end_src

Use ~text-mode~ for all new buffer by default if nothing more specific can be
chosen.

#+begin_src emacs-lisp
(setq-default major-mode 'text-mode)
#+end_src

Column beyond which automatic line-wrapping should happen. By default it's set
to 70, I set it globally to 79 as it's the most used value and redefine this
value for some specific modes.

#+begin_src emacs-lisp
(setq-default fill-column 79)
#+end_src

*** Inhibit implied resize frame

I use xmonad as my window manager and it controls all window resizing
operations. It's very unlikely that I'm gonna have some unpredictable behavior
of frames, but I prefer to set settings explicitly.

#+begin_src emacs-lisp
(setq-default frame-inhibit-implied-resize t)
#+end_src

*** Hide highlight in non-selected windows

#+begin_src emacs-lisp
(setq-default highlight-nonselected-windows nil)
#+end_src

*** Hide help echo text

#+begin_src emacs-lisp
(setq-default show-help-function nil)
#+end_src

*** Always avoid GUI

Do not use dialog boxes to ask questions for mouse commands.

#+begin_src emacs-lisp
(setq-default use-dialog-box nil)
#+end_src

*** No beeping and blinking in terminal

#+begin_src emacs-lisp
(setq-default ring-bell-function #'ignore
              visible-bell nil)
#+end_src

*** More convenient scrolling settings

Default scrolling settings in emacs is a bit distracting. Achieve a smooth
scrolling in emacs is almost impossible but it's possible to make the scrolling
behavior more comfortable.

#+begin_src emacs-lisp
(setq scroll-margin 3
      scroll-conservatively 101
      scroll-up-aggressively 0.01
      scroll-down-aggressively 0.01
      scroll-preserve-screen-position t
      auto-window-vscroll nil)
#+end_src

*** Limit wait for X event timeout

Emacs will wait up to this many seconds to receive X events after making
changes which affect the state of the graphical interface.  Under some window
managers this can take an indefinite amount of time, so it is important to
limit the wait.

Setting this value to ~nil~ fixes helm performance issue.

#+begin_src emacs-lisp
(setq x-wait-for-event-timeout nil)
#+end_src

*** Single line horizontal scrolling

Starting from version 26.3 emacs provides automatic horizontal scrolling
depends on cursor position. I set this variable to ~t~ to allow horizontal
scrolling of entire window content.

#+begin_src emacs-lisp
(setq auto-hscroll-mode t)
#+end_src

*** Enable recursive minibuffers

Enable recursive minibuffers. Required for some helm functionality.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

*** Use built-in tooltips

I use Lucid emacs, so it's very unlikely that it's gonna use Gtk+ tooltips, but
I prefer to disable it just in case.

#+begin_src emacs-lisp
(setq x-gtk-use-system-tooltips nil)
#+end_src

** Default input method

I write in 2 languages in emacs: English and Russian. To be able to switch
between input methods without losing keybindings you have to set
~default-input-method~ and use ~C-\~ keybinding.

#+begin_src emacs-lisp
(setq default-input-method "russian-computer")
#+end_src

** Files handling

Defines most of Emacs's file- and directory-handling settings, including basic
file visiting, backup generation, link handling, ITS-id version control, load-
and write-hook handling etc.

Overview of settings covered in this section:
- Auto saving settings :: I want to keep maximum 10 last versions of file to be
  able to restore it to previous state. It's very rare case and I don't think I
  need more that 10 backup files. To keep emacs directory clean I create
  separate directory where I'm going to store all backup and autosave
  files. Also I'm gonna store helm history file and org clock file in this
  directory and maybe something else related to restoring files and states.
- Large files threshold :: Emacs can display warning if you try to visit very
  large file. Default value is 10M, I'll increase it to 100M.
- Kill confirmation :: I use emacs client and restart emacs server with
  systemctl command. If emacs wait for confirmation restarting will stuck, so
  disable all confirmation prompt.

#+begin_src emacs-lisp
(use-package files
  :ensure nil
  :config
  (unless (file-exists-p rr-savefile-dir)
    (make-directory rr-savefile-dir))

  (setq backup-directory-alist
        `((".*" . ,rr-backup-dir)))

  (setq delete-old-versions t
        kept-old-versions 10)

  (setq large-file-warning-threshold (* 100 1024 1024))

  (setq confirm-kill-processes nil
        confirm-kill-emacs nil))
#+end_src

** Configure new windows display position

By default when you open new window it's not predictable where it's going to
appear. It's possible to fix it and adjust to your needs. All you need is
variable ~display-buffer-alist~. I used [[https://depp.brause.cc/shackle/][shackle]] for a while but I want to have
better understanding of what I'm doing and avoid usage of external packages if
it's possible to achieve the same with built-in functionality.

I don't use side windows, because they're fixed at the edge of emacs frame and
sometimes lead to unpredictable behavior.

#+begin_src emacs-lisp
(defconst parameters
  '(window-parameters . ((no-other-window . t)
                         (no-delete-other-windows . t))))

(defconst parameters-no-mode-line
  '(window-parameters . ((no-other-window . t)
                         (no-delete-other-windows . t)
                         (mode-line-format . none))))

(setq switch-to-buffer-obey-display-actions nil)

(defconst display-buffer-same-window-commands
  '(compile-goto-error
    push-button
    magit-diff-visit-file
    magit-todos-jump-to-item
    deadgrep-visit-result-other-window))

(defconst display-buffer-bottom-regexps
  (mapcar (lambda (s) (concat "\\*" s "\\*"))
          '("[H|h]elp.*?"
            "Disabled\sCommand"
            "deadgrep.*?"
            "rg"
            "cider-doc"
            "Backtrace"
            "Apropos"
            "Python.*?"
            "grep"
            "lsp-help"
            "compilation"
            "cider-inspect"
            "Calendar"
            "Org\sSelect"
            ".*?\sserver\slog"
            "Completions"
            "Compile-Log"
            "Async\sShell\sCommand"
            "Shell\sCommand\sOutput"))
  "List of buffer name regexps.
All matched buffers should be displayed at
bottom of the frame.")

(defconst helm-buffers-regexps
  '("\\*helm.*?\\*"
    "\\*cljr.*?\\*"
    "\\*lsp-java select\\*")
  "List of helm buffer regexps.")

(defun bottom-special-buffer-p (buf &rest _)
  "Predicate to display BUF in bottom of the frame."
  (seq-contains-p display-buffer-bottom-regexps buf #'string-match-p))

(defun helm-buffer-p (buf &rest _)
  "Predicate for helm BUF."
  (seq-contains-p helm-buffers-regexps buf #'string-match-p))

(setq display-buffer-alist
      `(
        ;; Magit
        ("magit:.*"
         (display-buffer-reuse-mode-window
          display-buffer-at-bottom)
         (window-height . 0.4))
        ("magit-log:.*"
         (display-buffer-reuse-mode-window
          display-buffer-same-window))
        ("magit-refs:.*"
         (display-buffer-reuse-mode-window
          display-buffer-same-window))
        ("magit-diff.*"
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (direction . rightmost)
         (window-width . 0.5))
        ("magit-revision:.*"
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (direction . rightmost)
         (window-width . 0.5))
        ("COMMIT_EDITMSG"
         (display-buffer-reuse-mode-window
          display-buffer-same-window))
        ;; Google translate buffer
        ("\\*Google\sTranslate\\*"
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (direction . rightmost)
         (window-width . 0.5))
        ;; Flycheck error list
        ("\\*Flycheck\serrors.*\\*"
         (display-buffer-reuse-mode-window
          display-buffer-in-side-window)
         (window-height . 0.2)
         (side . bottom)
         (slot . 0)
         (preserve-size . (nil . t))
         ,parameters)
        ;; Org mode
        ;; ("\\*Org\sSrc.*\\*"
        ;;  (display-buffer-reuse-mode-window
        ;;   display-buffer-in-direction)
        ;;  (direction . rightmost)
        ;;  (window-width . 0.5))
        ;; Helm
        (,#'helm-buffer-p
         (display-buffer-in-direction)
         (window-height . 0.4)
         (direction . bottom)
         ,parameters)
        ;; Bottom special buffers
        (,#'bottom-special-buffer-p
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (window-height . 0.4)
         (direction . bottom)
         ,parameters)
        ("\\*cider-error\\*"
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (direction . rightmost)
         (window-width . 0.5))
        ("\\*cider-test-report"
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (direction . rightmost)
         (window-width . 0.5))
        ("\\*cider-repl.*$"
         (display-buffer-reuse-mode-window
          display-buffer-at-bottom)
         (window-height . 0.3))
        ;; Open clickable text
        ((lambda (&rest _)
           (memq this-command display-buffer-same-window-commands))
         (display-buffer-reuse-mode-window
          display-buffer-in-direction)
         (direction . rightmost)
         (window-width . 0.5))))

(setq window-combination-resize nil
      switch-to-buffer-in-dedicated-window nil)
#+end_src

** Auth sources

I prefer to control what should be stored in the ~.authinfo~ file manually, so
I disable save behavior.

#+begin_src emacs-lisp
(use-package auth-source
  :ensure nil
  :config
  (setq auth-source-save-behavior nil))
#+end_src

** Replace selected text on input

By default if you select some part of buffer and start typing selected part
won't be deleted. I find this behavior not obvious and not convenient. To fix
it I use ~delete-selection-mode~.

#+begin_src emacs-lisp
(use-package delsel
  :ensure nil
  :config
  (delete-selection-mode))
#+end_src

** Built-in help

When I use help functions (~describe-variable~ or ~describe-function~) I want
help popup window is selected by default.

#+begin_src emacs-lisp
(use-package help
  :ensure nil
  :config
  (setq help-window-select t))
#+end_src

** Settings related to mouse usage

*** Disable tooltips

I prefer minimum of distractions during work. One of them is tooltips. I
disable =tooltip-mode= in =early-init.el=. Here some related settings.

#+begin_src emacs-lisp
(use-package tooltip
  :ensure nil
  :config
  (setq tooltip-use-echo-area nil
        show-help-function nil))
#+end_src

*** Disable modeline on-hover tooltips

#+begin_src emacs-lisp
(setq-default mode-line-default-help-echo nil)
#+end_src

*** Move mouse away from text

Built-in ~mouse-avoidance-mode~ allows to move cursor away from text as soon as
you start typing.

#+begin_src emacs-lisp
(use-package avoid
  :ensure nil
  :config
  (if (display-mouse-p)
      (mouse-avoidance-mode 'banish)))
#+end_src

*** Mouse paste behavior

By default on middle click yanked text will be pasted in the place where mouse
pointer is. But more convenient option is to paste yanked text right after
cursor.

#+begin_src emacs-lisp
(use-package mouse
  :ensure nil
  :config
  (setq-default mouse-yank-at-point t))
#+end_src

** GnuTLS

Set explicit minimum number of prime bits accepted by GnuTLS for key exchange
to increase security.

#+begin_src emacs-lisp
(use-package gnutls
  :ensure nil
  :config
  (setq gnutls-min-prime-bits 4096))
#+end_src

** Highlight current line

This built-in mode highlights current line where the cursor is at the moment. I
used to use ~global-hl-line-mode~ but for some major modes I find it not really
useful (in org-mode buffers it shows hidden leading stars for current line), so
I enable it manually for certain modes.

#+begin_src emacs-lisp
(use-package hl-line
  :ensure nil
  :config
  (setq hl-line-sticky-flag nil)
  (add-hook 'prog-mode-hook #'hl-line-mode)
  (add-hook 'nxml-mode-hook #'hl-line-mode))
#+end_src

** Major mode for editing configuration files

By default all config files which ends with =rc= are opened in
~text-mode~. Emacs has built-in ~conf-unix-mode~ for such files. To set this
mode automatically I have to modify ~auto-mode-alist~ variable.

#+begin_src emacs-lisp
(use-package conf-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.*rc$" . conf-unix-mode)))
#+end_src

** Set specific browser to open links

I use Firefox as my default browser so I want emacs to open any links in it.

#+begin_src emacs-lisp
(use-package browse-url
  :ensure nil
  :config
  (setq browse-url-browser-function 'browse-url-firefox))
#+end_src

** Image mode

Play animated images loop forever instead of just once.

#+begin_src emacs-lisp
(use-package image-mode
  :ensure nil
  :config
  (setq image-animate-loop t))
#+end_src

** Be quiet at startup

Don't show any help pages or startup messages in the echo area. On startup just
show empty scratch buffer without any text in it.

#+begin_src emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      initial-scratch-message nil)
#+end_src

** Unique buffer names

If 2 buffers have similar file name or base name there should be some way to
distinguish them. That why ~uniquify~ package for. I update some settings to
achieve desired behavior here.

#+begin_src emacs-lisp
(use-package uniquify
  :ensure nil
  :config
  (setq uniquify-separator "/"
        uniquify-buffer-name-style 'forward
        uniquify-strip-common-suffix t))
#+end_src

** More reliable inter-window border

The native border "consumes" a pixel of the fringe on righter-most splits,
~window-divider~ does not. Available since Emacs 25.1.

#+begin_src emacs-lisp
(use-package frame
  :ensure nil
  :config
  (setq-default window-divider-default-places t
                window-divider-default-bottom-width 0
                window-divider-default-right-width 1)
  (window-divider-mode +1))
#+end_src

** Graphic mode

I use emacsclient and run server as systemd unit. All graphic mode related
settings should be applied after first frame is created.

#+begin_src emacs-lisp
(defun rr/graphic-mode-settings ()
  "Setup for current FRAME."
  (setq-default line-spacing 0)
  ;; buffer name  in frame title
  (setq frame-title-format '("" "%b @ Emacs")))

(if (daemonp)
    (add-hook 'server-after-make-frame-hook #'rr/graphic-mode-settings)
  (rr/graphic-mode-settings))
#+end_src

** Tramp

Tramp mode is very powerful feature of emacs. You can open remote file just
like it's local. It's a bit slow with default settings so I update some
settings to slightly speed up this mode.

#+begin_src emacs-lisp
(use-package tramp
  :ensure nil
  :config
  (setq tramp-terminal-type "tramp"
        tramp-default-method "ssh"
        tramp-ssh-controlmaster-options "-o ControlMaster=auto -o ControlPath='tramp.%%C'"
        explicit-shell-file-name "/bin/bash"
        remote-file-name-inhibit-cache 3600
        tramp-completion-reread-directory-timeout nil
        vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                     vc-ignore-dir-regexp
                                     tramp-file-name-regexp)
        tramp-verbose 1
        auto-revert-remote-files nil)
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src

** Simple - tweaks not related to major mode or file handling

Settings not related to any major mode or file handling.

Overview of settings in this section:
- ~auto-fill-mode~ :: For all modes derived from ~text-mode~ I'd like to enable
  ~auto-fill-mode~ to restrict maximum line length to ~current-fill-column~
  value. When line length reach this value line break will be inserted
  automatically.
- Truncate lines :: For all modes derived from ~prog-mode~ I'd like to truncate
  long lines instead of folding them.
- Kill-ring :: Save stuff you've copied in other applications to the emacs
  kill-ring.
- Trailing whitespace :: I don't think there is any reason to keep trailing
  white spaces in text files. Let's remove them on every file save.
- Show column number :: Sometimes I need to know the column number for
  character at point, so let's put it to the mode-line.

#+begin_src emacs-lisp
(use-package simple
  :ensure nil
  :config
  (setq save-interprogram-paste-before-kill t)
  (add-hook 'text-mode-hook #'auto-fill-mode)
  (add-hook 'prog-mode-hook (lambda () (setq truncate-lines t)))
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (column-number-mode))
#+end_src

** Auto revert

If buffer file was changed externally revert buffer automatically, without
asking and printing any messages.

#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :config
  (setq auto-revert-verbose nil
        global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode 1))
#+end_src

** Recent files

Keep the history of recently visited files. Can be used directly using command
~recentf-open-files~ or in my case with help of ~helm~. Very handy.

#+begin_src emacs-lisp
(use-package recentf
  :ensure nil
  :config
  (setq recentf-save-file (expand-file-name "recentf" rr-savefile-dir)
        recentf-max-saved-items 50
        recentf-max-menu-items 15)
  (add-to-list 'recentf-exclude (expand-file-name "~/.emacs.d/"))
  (recentf-mode +1))
#+end_src

** EPA

When you need to decrypt something inside emacs you'll be asked to enter
password for GPG key. By default it shows system dialog window but we can use
emacs minibuffer to enter this password.

#+begin_src emacs-lisp
(use-package epg-config
  :ensure nil
  :config
  (setq epg-pinentry-mode nil))
#+end_src

** Imenu

Imenu provides indexed list of items in the buffer (definitions, variables,
imports etc.) to quickly jump to the position of the particular item. Can be
used directly by calling ~imenu~ or with some helpful incremental searching
frameworks like ~ivy~ or ~helm~.

#+begin_src emacs-lisp
(use-package imenu
  :ensure nil
  :config
  (setq imenu-auto-rescan t
        imenu-max-item-length 160
        imenu-max-items 100))
#+end_src

** Navigation by sub-words

For some programming languages (like Java for example) it's common to use camel
case naming notation. This minor mode makes emacs recognize separate words
which are written using this notation and allows to use standard emacs
navigation on it.

#+begin_src emacs-lisp
(use-package subword
  :ensure nil
  :config
  (add-hook 'prog-mode-hook #'subword-mode))
#+end_src

** Ediff

Ediff is powerful diff and merging tool in emacs. Some settings I want to
adjust:
- Do not produce separate frame for navigation and help
- Change default layout

#+begin_src emacs-lisp
(use-package ediff
  :ensure nil
  :config
  (setq ediff-window-setup-function #'ediff-setup-windows-plain
        ediff-split-window-function #'split-window-right))
#+end_src

** ANSI colors

Add support for ANSI colors in the shell buffers and in compilation mode
buffers.

#+begin_src emacs-lisp
(use-package ansi-color
  :ensure nil
  :config
  (setq ansi-color-for-comint-mode t)

  (defun colorize-compilation-buffer ()
    "Use ansi colors to colorize compipaiton buffer."
    (toggle-read-only)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (toggle-read-only))

  (add-hook 'shell-mode-hook #'ansi-color-for-comint-mode-on)
  (add-hook 'compilation-filter-hook #'colorize-compilation-buffer))
#+end_src

** Compilation mode settings

Make compilation mode a little bit more convenient to use.

#+begin_src emacs-lisp
(use-package compile
  :ensure nil
  :config
  (setq compilation-always-kill t        ; kill compilation process before starting another
        compilation-ask-about-save nil   ; save all buffers on `compile'
        compilation-scroll-output t)
  (define-key compilation-mode-map (kbd "q") #'delete-window))
#+end_src

** Save history

Keep history of certain variables persistent between emacs sessions. You can
keep minibuffer history, kill-ring, helm commands and many more.

#+begin_src emacs-lisp
(use-package savehist
  :ensure nil
  :config
  (setq history-delete-duplicates t
        savehist-save-minibuffer-history 1
        savehist-file (expand-file-name "savehist" rr-savefile-dir)
        savehist-additional-variables '(kill-ring
                                        search-ring
                                        regexp-search-ring
                                        extended-command-history
                                        shell-command-history))
  (savehist-mode 1))
#+end_src

** Windows splitting preferences

Do not split windows from top to bottom unless I do it explicitly. Always
prefer side by side splitting.

#+begin_src emacs-lisp
;; (setq split-window-preferred-function #'split-window-prefer-side-by-side)
(setq display-buffer-reuse-frames t
      split-height-threshold 80
      split-width-threshold 160)
(setq split-window-preferred-function #'split-window-sensibly)
#+end_src

** Minibuffer

So far the settings below are only for completion styles. Since emacs 27.1
there is new ~flex~ completion style available. It's written in C hence it's
very fast. Let's include it to the ~completion-styles~ list to be able to use
it with ~helm~ or ~capf~.

#+begin_src emacs-lisp
(use-package minibuffer
  :ensure nil
  :config
  (setq completion-styles '(basic partial-completion emacs22 initials flex))
  (minibuffer-electric-default-mode 1))
#+end_src

** Comint

Command-interpreter-in-a-buffer package (comint mode). The idea is that you can
build specific process-in-a-buffer modes on top of comint mode -- e.g., Lisp,
shell, scheme, T, soar, etc. This way, all these specific packages share a
common base functionality, and a common set of bindings, which makes them
easier to use (and saves code, implementation time, etc., etc.).

Several packages are already defined using comint mode:
- ~shell.el~ :: defines a shell-in-a-buffer mode.
- ~cmulisp.el~ :: defines a simple lisp-in-a-buffer mode.

#+begin_src emacs-lisp
(use-package comint
  :ensure nil
  :config
  (setq comint-scroll-to-bottom-on-input t
        comint-move-point-for-output t
        comint-prompt-read-only t
        comint-input-ignoredups t
        comint-completion-addsuffix t))
#+end_src

** Shell

Emacs has built-in shell, which behaves like normal emacs buffer and integrates
well with built-in completion frameworks. Shell mode based on comint mode.

I don't use it at the moment. I use external terminal emulator and ~eshell~.

#+begin_src emacs-lisp
(use-package shell
  :ensure nil
  :config
  (setq shell-command-prompt-show-cwd t))
#+end_src

** EShell

Very powerful shell written in ELisp, so it works on all platforms and has
better integration with emacs tools and packages.

Basically, Eshell is used just like shell mode (<M-x shell>). The keystrokes
for navigating the buffer, and accessing the command history, are identical.
Unlike shell mode, however, Eshell mode's governing process is Emacs itself.
With shell mode, an inferior shell process is executed that communicates with
Emacs via comint -- a mode for handling sub-process interaction. Eshell mode,
on the other hand, is a truly native Emacs shell. No subprocess are invoked
except the ones requested by the user at the prompt.


#+begin_src emacs-lisp
(use-package esh-mode
  :ensure nil
  :config
  (setq eshell-scroll-to-bottom-on-input t
        eshell-scroll-to-bottom-on-output t
        eshell-destroy-buffer-when-process-dies t))
#+end_src


** Save place

Remember last position in visited file and restore it after open this file next
time. Works even after emacs restarts.

#+begin_src emacs-lisp
(use-package saveplace
  :ensure nil
  :config
  (setq save-place-file (expand-file-name "saveplace" rr-savefile-dir))
  (save-place-mode 1))
#+end_src

** Web browser and HTML parser

Render HTML pages as plain text. Some settings allows to disable custom fonts
and colors, setup better rendering for tables and images. Not perfect but at
least HTML emails usually readable.

#+begin_src emacs-lisp
(use-package shr
  :ensure nil
  :commands (eww eww-browse-url)
  :config
  (setq shr-use-fonts nil
        shr-use-colors nil
        shr-max-image-proportion 0.2
        shr-table-horizontal-line nil
        shr-table-vertical-line ?\s
        shr-table-corner ?\s
        shr-width (current-fill-column)))
#+end_src

And third party package for proper syntax highlighting for pre tags in HTML:

#+begin_src emacs-lisp
(use-package shr-tag-pre-highlight
  :after shr
  :config
  (add-to-list 'shr-external-rendering-functions
               '(pre . shr-tag-pre-highlight)))
#+end_src

** Isearch

Built-in searching package. Starting from version 27.1 has some useful
settings.

Some settings I use:
- Treat whitespace symbol as =.*?= regexp.
- Include counter of found items into the prompt.

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :config
  (setq search-whitespace-regexp ".*?"
        isearch-lazy-count t
        lazy-count-prefix-format "(%s/%s) "
        isearch-allow-scroll 'unlimited))
#+end_src

** Xref

Built-in package which provides a somewhat generic infrastructure for cross
referencing commands, in particular =find-definition=. The implementation
itself is language specific but some common settings are placed in this
package.

Overview of my xref settings:
- Do not prompt for identifier if there is resolvable symbol at point.
- Show only the non-directory (a.k.a. "base name") part of the file name.

#+begin_src emacs-lisp
(use-package xref
  :config
  (setq xref-file-name-display 'nondirectory
        xref-prompt-for-identifier nil))
#+end_src

** ElDoc

Show signature of function or describe symbol at point in minibuffer.

#+begin_src emacs-lisp
(use-package eldoc
  :ensure nil
  :config
  (global-eldoc-mode))
#+end_src

** Dired

Very powerful file manager inside of emacs.

Some descriptions for my settings:
- If 2 dired buffers are opened and you want to move or copy file or directory
  the other dired buffer location will be suggested as destination by default.
- Copy or delete directory is recursive by default.
- Activate ~hl-line-mode~ in all dired buffers.

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :config
  (setq dired-listing-switches "-AGFhlv --group-directories-first --time-style=long-iso"
        dired-dwim-target t
        dired-recursive-copies 'always
        dired-recursive-deletes 'always)

  (add-hook 'dired-mode-hook #'hl-line-mode))

(use-package dired-aux
  :ensure nil
  :config
  (setq dired-isearch-filenames 'dwim
        dired-create-destination-dirs 'ask
        dired-vc-rename-file t))
#+end_src

*** Image dired

Show images preview and perform some image-specific operations in the
dired-like way. Can be used also as image viewer.

#+begin_src emacs-lisp
(use-package image-dired
  :ensure nil
  :config
  (setq image-dired-thumb-size 200
        image-dired-thumb-margin 2
        image-dired-thumbs-per-row 4))
#+end_src

*** Dired plus

Not built-in package. I have this only for one function (and probably the
entire emacs wiki repository). I don't know why the default behavior is so
weird: dired creates new buffer every time I navigate by directory tree. This
package fixes it.

#+begin_src emacs-lisp
(use-package dired+
  :config
  (toggle-diredp-find-file-reuse-dir 1))
#+end_src

*** Dired GIT info

Also third party package. Show GIT information in dired buffers. Quiet handy
sometimes, I disable it by default and activate manually by pressing =)= key.

#+begin_src emacs-lisp
(use-package dired-git-info
  :config
  (with-eval-after-load 'dired
    (define-key dired-mode-map ")" #'dired-git-info-mode)))
#+end_src

** Calendar

Some tweaks for built-in calendar. I want the week starts from Monday and
display date in ISO format.

#+begin_src emacs-lisp
(use-package calendar
  :ensure nil
  :config
  (setq calendar-week-start-day 1
        calendar-date-style 'iso))
#+end_src

** Spell checking

Spell checking in emacs relies on some external utility, which should be
installed on the OS level. I use ~aspell~.

Besides standard spell checking for ~text-mode~ derived modes there is smart
spell checking mode for programming, which check typos in comments and constant
strings but not in the rest of source code.

#+begin_src emacs-lisp
(use-package ispell
  :ensure nil
  :config
  (setq ispell-program-name "aspell")
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode))
#+end_src

** Regexps

Built-in regex package. I don't use regex too much so I don't really need some
powerful packages like =visual-regex= or something like this.

#+begin_src emacs-lisp
(use-package re-builder
  :ensure nil
  :config
  (setq reb-re-syntax 'read)
  (global-set-key (kbd "C-c R") #'re-builder))
#+end_src

* Appearance

All tweaks for emacs look & feel. Color themes fonts modeline etc.

** Color scheme

*** Zenburn theme

Very nice theme. Used to use it for a long time, but I found that more contrast
theme is more comfortable for my eyes. I'll keep this section for history with
all my customization in case I want ever to switch back to it.

#+begin_src emacs-lisp
(use-package zenburn-theme
  :config
  (setq zenburn-use-variable-pitch nil)

  (defun rr/apply-theme ()
    "Apply some customizaitons to current theme."
    (load-theme 'zenburn t)
    (zenburn-with-color-variables
      (custom-theme-set-faces
       'zenburn
       `(helm-delete-async-message ((t (:foreground ,zenburn-yellow))))
       `(helm-ff-file-extension ((t (:foreground ,zenburn-red+2))))
       ;; Button
       `(button ((t (:foreground ,zenburn-yellow :underline t))))
       ;; Flycheck posframe
       `(flycheck-posframe-info-face ((t (:inherit 'success))))
       `(flycheck-posframe-warning-face ((t (:inherit 'warning))))
       `(flycheck-posframe-error-face ((t (:inherit 'error))))
       `(flycheck-posframe-background-face ((t (:background ,zenburn-bg+05))))
       `(flycheck-posframe-border-face ((t (:foreground ,zenburn-fg-1))))
       ;; Eyebrowse
       `(eyebrowse-mode-line-active ((t (:inherit 'mode-line-emphasis :foreground ,zenburn-yellow))))
       `(eyebrowse-mode-line-inactive ((t (:foreground ,zenburn-fg-1))))
       ;; VC state
       `(vc-edited-state ((t :inherit 'vc-state-base :foreground ,zenburn-blue)))
       `(vc-up-to-date-state ((t :inherit 'vc-state-base :foreground ,zenburn-green+4)))
       `(vc-removed-state ((t :inherit 'vc-state-base :foreground ,zenburn-red)))
       `(vc-conflict-state ((t :inherit 'vc-state-base :foreground ,zenburn-orange)))
       `(vc-locally-added-state ((t :inherit 'vc-state-base :foreground ,zenburn-fg)))
       `(vc-needs-update-state ((t :inherit 'vc-state-base :foreground ,zenburn-yellow)))
       `(vc-missing-state ((t :inherit 'vc-state-base :foreground ,zenburn-fg-05)))
       ;; Set fringe color the same as background
       `(fringe ((t (:background ,zenburn-bg))))
       ;; Less contrast window divider
       `(window-divider ((t (:foreground ,zenburn-fg-1))))
       ;; Mu4e
       `(mu4e-header-highlight-face ((t (:inherit 'hl-line :weight bold))))
       ;; Some org-mode faces
       `(org-mode-line-clock ((t (:background nil))))
       `(org-headline-todo ((t (:foreground ,zenburn-red+2))))
       `(org-drawer ((t (:foreground ,zenburn-blue-2))))
       `(org-ellipsis ((t (:foreground ,zenburn-yellow-1))))
       `(org-checkbox ((t (:background ,zenburn-bg+2 :foreground ,zenburn-fg+1
                                       :box (:line-width 1 :color ,zenburn-fg-1)))))
       ;; `(org-table ((t (:background ,zenburn-bg-05))))
       ;; Make all normal weight -> semi-bold
       `(link-visited ((t (:foreground ,zenburn-yellow-2 :underline t))))
       `(w3m-arrived-anchor ((t (:foreground ,zenburn-yellow-2 :underline t))))
       `(git-annex-dired-annexed-available ((t (:inherit success))))
       `(git-annex-dired-annexed-unavailable ((t (:inherit error))))
       `(helm-ff-file ((t (:foreground ,zenburn-fg :background ,zenburn-bg))))
       `(helm-ff-executable ((t (:foreground ,zenburn-green+2 :background ,zenburn-bg))))
       `(helm-ff-prefix ((t (:foreground ,zenburn-bg :background ,zenburn-yellow))))
       `(ledger-font-payee-cleared-face ((t (:foreground ,zenburn-fg))))
       `(ledger-font-payee-pending-face ((t (:foreground ,zenburn-red))))
       `(ledger-font-auto-xact-face ((t (:foreground ,zenburn-yellow-1))))
       `(ledger-font-periodic-xact-face ((t (:foreground ,zenburn-green))))
       `(ledger-font-pending-face ((t (:foreground ,zenburn-orange))))
       `(ledger-font-posting-date-face ((t (:foreground ,zenburn-orange))))
       `(ledger-font-reconciler-cleared-face ((t (:foreground ,zenburn-fg))))
       `(ledger-font-reconciler-pending-face ((t (:foreground ,zenburn-orange))))
       `(ledger-font-report-clickable-face ((t (:foreground ,zenburn-orange))))
       `(magit-popup-disabled-argument ((t (:foreground ,zenburn-fg-1))))
       `(magit-filename ((t ())))))
    (enable-theme 'zenburn)
    (remove-hook 'server-after-make-frame-hook 'rr/apply-theme))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'rr/apply-theme)
    (rr/apply-theme)))
#+end_src

*** COMMENT Gruvbox

#+begin_src emacs-lisp
(use-package gruvbox-theme
  :config
  (defun rr/apply-gruvbox-theme ()
    "Apply gruvbox theme."
    (load-theme 'gruvbox-dark-medium t)
    (enable-theme 'gruvbox-dark-medium)
    (remove-hook 'server-after-make-frame-hook #'rr/apply-gruvbox-theme))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'rr/apply-gruvbox-theme)
    (rr/apply-gruvbox-theme)))
#+end_src

*** COMMENT Tomorrow theme

#+begin_src emacs-lisp
(use-package color-theme-sanityinc-tomorrow
  :config
  (defun rr/apply-tomorrow-theme ()
    "Apply tomorrow theme."
    (load-theme 'sanityinc-tomorrow-night t)
    (let ((background "#1d1f21")
          (alt-background "#22a224a427a7")
          (current-line "#282a2e")
          (selection "#373b41")
          (foreground "#c5c8c6")
          (comment "#969896")
          (red "#cc6666")
          (orange "#de935f")
          (yellow "#f0c674")
          (green "#b5bd68")
          (aqua "#8abeb7")
          (blue "#81a2be")
          (purple "#b294bb"))
      (custom-theme-set-faces
       'sanityinc-tomorrow-night
       `(helm-ff-file-extension ((t (:foreground ,red :extend t))))
       `(helm-match ((t :foreground ,blue :bold t)))
       `(org-headline-done ((t (:foreground ,green))))
       `(org-headline-todo ((t (:foreground ,orange))))
       `(org-priority ((t (:foreground ,yellow))))
       `(fringe ((t (:background ,background))))
       `(org-mode-line-clock ((t (:background nil))))))
    (enable-theme 'sanityinc-tomorrow-night)
    (remove-hook 'server-after-make-frame-hook #'rr/apply-tomorrow-theme))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'rr/apply-tomorrow-theme)
    (rr/apply-tomorrow-theme)))
#+end_src

*** COMMENT Modus vivendi

Currently used. My favorite one and the most consistent. A lot of built-in
customization, very actively maintained.

#+begin_src emacs-lisp
(use-package modus-vivendi-theme
  :init
  (setq modus-vivendi-theme-bold-constructs t
        modus-vivendi-theme-slanted-constructs nil
        modus-vivendi-theme-syntax nil
        modus-vivendi-theme-org-blocks 'greyscale
        modus-vivendi-theme-prompts 'subtle
        modus-vivendi-theme-proportional-fonts nil)
  :config
  (defun rr/apply-modus-theme ()
    "Apply custom theme."
    (load-theme 'modus-vivendi t)
    (modus-vivendi-theme-with-color-variables
      (custom-theme-set-faces
       'modus-vivendi
       `(font-lock-type-face ((t (:foreground ,magenta-alt))))))
    (enable-theme 'modus-vivendi)
    (remove-hook 'server-after-make-frame-hook #'rr/apply-modus-theme))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'rr/apply-modus-theme)
    (rr/apply-modus-theme)))
#+end_src

*** COMMENT Modus operandi

Light variant of modus theme. I use it on demand in very rare cases.

#+begin_src emacs-lisp
(use-package modus-operandi-theme
  :init
  (setq modus-operandi-theme-bold-constructs t
        modus-operandi-theme-slanted-constructs t
        modus-operandi-theme-org-blocks 'greyscale
        modus-operandi-theme-proportional-fonts nil)
  :config
  (defun rr/apply-modus-theme ()
    "Apply custom theme."
    (load-theme 'modus-operandi t)
    (remove-hook 'server-after-make-frame-hook #'rr/apply-modus-theme))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook #'rr/apply-modus-theme)
    (rr/apply-modus-theme)))
#+end_src

** Modeline

*** Flycheck status

This is adapted variant of similar function from [[https://github.com/TheBB/spaceline][spaceline]] package.

#+begin_src emacs-lisp
(defun rr/flycheck-mode-line-status-text (&optional status)
  "Get a text describing STATUS for use in the mode line.

STATUS defaults to `flycheck-last-status-change' if omitted or
nil."
  (let ((text (pcase (or status flycheck-last-status-change)
                (`not-checked " ")
                (`no-checker " - ")
                (`running " * ")
                (`errored " ! ")
                (`finished
                 (let-alist (flycheck-count-errors flycheck-current-errors)
                   (concat
                    (propertize (format " • %s " (or .error "✓")) 'face `(:inherit error))
                    (propertize (format "• %s " (or .warning "✓")) 'face `(:inherit warning))
                    (propertize (format "• %s " (or .info "✓")) 'face `(:inherit success))
                    )))
                (`interrupted " . ")
                (`suspicious " ? "))))
    (propertize text)))

(add-to-list 'global-mode-string '(:eval (rr/flycheck-mode-line-status-text)))
#+end_src

*** Minions

I don't like to see a lot of minor mode indicators in the modeline. This mode
hide them but keep all the information accessible on mouse click.

#+begin_src emacs-lisp
(use-package minions
  :config
  (setq minions-direct '(pyvenv-mode projectile-mode))
  (minions-mode 1))
#+end_src

** Set default fonts

I used to set default font through ~.Xresources~ and it was working good. But
it wasn't flexible enough. Now I have some helpful functions to set font-size
globally.

Some good fonts I used to use or ready to consider:
+ [[https://slackbuilds.org/repository/14.2/system/Iosevka/][Iosevka]] :: Too narrow.
+ [[https://github.com/mozilla/Fira][Fira Mono]] :: Can't figure out how to make italic work.
+ [[https://github.com/adobe-fonts/source-code-pro][SourceCodeVariable]] :: Best option for me. Currently used.
+ IBM Plex Mono :: Really good but on laptop's small screen looks a bit ugly.

#+begin_src emacs-lisp
(defconst fixed-pitch-font-family "Source Code Pro"
  "Font family for default and fixed-pitch faces.")

(defconst variable-pitch-font-family "Source Sans Pro"
  "Font family for variable-pitch face.")

(defconst font-size-alist
  '((normal . 80)
    (large . 120)
    (huge . 140))
  "List of available font sizes.")

(defun rr/set-font (height)
  "Set fonts HEIGHT for all base faces."
  (set-face-attribute 'default nil :family fixed-pitch-font-family :weight 'semi-bold :height height)
  (set-face-attribute 'fixed-pitch nil :family fixed-pitch-font-family :weight 'semi-bold :height height)
  (set-face-attribute 'variable-pitch nil :family variable-pitch-font-family :weight 'semi-bold :height height))

(defun rr/select-font-size ()
  "Select font size from predefined list."
  (interactive)
  (let ((height (alist-get (intern (completing-read "Select font size:" font-size-alist)) font-size-alist)))
    (rr/set-font height)))

(define-key global-map (kbd "C-c r f") #'rr/select-font-size)

(rr/set-font 80)
#+end_src

** Show eldoc in child frame

Display =eldoc= function signatures in child frame at point.

#+begin_src emacs-lisp
(use-package eldoc-box
  :disabled)
#+end_src

** Tree sitter

Alternative to built-in syntax highlighting.

#+begin_src emacs-lisp
(use-package tree-sitter)

(use-package tree-sitter-langs
  :after tree-sitter
  :config
  (tree-sitter-require 'java)
  (tree-sitter-hl-add-patterns 'java
    [
     ;; import scope
     (import_declaration
      (identifier) @attribute
      (.match? @attribute "^[a-z]"))

     ;; import class name
     (import_declaration
      (identifier) @type
      (.match? @type "^[A-Z]"))

     ;; local variable name
     (local_variable_declaration
      (variable_declarator (identifier) @variable))

     ;; Method argument name
     (formal_parameter
      (identifier) @variable)

     ;; Method argument name array
     (spread_parameter
      (variable_declarator
       (identifier) @variable))

     ;; Catch exception argument name
     (catch_formal_parameter
      (identifier) @variable)

     ;; Class field
     (field_declaration
      (modifiers)
      (variable_declarator
       (identifier) @variable.parameter
       (.match? @variable.parameter "^[a-z]")))

     ;; Constant
     (field_declaration
      (modifiers "final")
      (variable_declarator
       (identifier) @constant
       (.match? @constant "^[A-Z]")))

     ;; var keyword (for java 11)
     ((type_identifier) @keyword
      (.match? @keyword "^var$"))

     ;; @interface name
     (annotation_type_declaration
      name: (identifier) @type)

     ;; @interface keyword
     ("@interface" @keyword)

     ;; method name declaration
     (method_declaration
      name: (identifier) @function)

     ;; method call
     (method_invocation
      name: (identifier) @function.call)

     ;; Scoped annotations
     (annotation
      (scoped_identifier) @attribute)

     (marker_annotation
      (scoped_identifier) @attribute)

     ;; class as argument
     (class_literal
      (identifier) @type)

     ;; Use keyword face for super
     ((super) @keyword)

     ;; Use keyword face for this
     ((this) @keyword)
     ])

  (add-hook 'java-mode-hook #'tree-sitter-hl-mode)
  (add-hook 'java-mode-hook
            (lambda ()
              (add-function :before-until (local 'tree-sitter-hl-face-mapping-function)
                            (lambda (capture-name)
                              (pcase capture-name
                                ("attribute" 'font-lock-constant-face)
                                ("operator" 'font-lock-constant-face)
                                ("variable.parameter" 'font-lock-function-name-face)
                                ("type.builtin" 'font-lock-keyword-face)
                                ("function.call" 'default))))))

  ;; TypeScript
  (tree-sitter-require 'typescript)
  (add-hook 'typescript-mode-hook #'tree-sitter-hl-mode)

  ;; Rust
  (tree-sitter-require 'rust)
  (add-hook 'rust-mode-hook #'tree-sitter-hl-mode))
#+end_src

* Incremental completion

I've tried ~ivy~, ~helm~ and emacs default completion framework and I find helm
something I cannot use emacs without.

** Helm

Very powerful incremental completion framework with a lot of extensions and
customization.

*** Helm core

This section contains custom settings for core helm package. I've described all
settings in the comments (there is a lot of them).

#+begin_src emacs-lisp
(use-package helm
  :config
  (require 'helm)
  (require 'helm-config)
  (require 'helm-files)
  (require 'helm-grep)

  (when (executable-find "curl")
    (setq helm-net-prefer-curl t))

  ;; General settings
  (setq helm-split-window-inside-p            nil ; open helm buffer inside current window, not occupy whole other window
	      helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	      helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	      helm-echo-input-in-header-line nil      ; hide duplicated echo input
	      helm-display-header-line nil            ; hide header line, keep the interface as clear as possible
        helm-buffer-max-length 40               ; some buffer names too long
	      helm-inherit-input-method nil           ; use default input method by default in helm buffers
        helm-truncate-lines t                   ; avoid line splitting in helm buffer
        helm-M-x-always-save-history t          ; preserve history for `helm-M-x' command
        helm-buffers-truncate-lines t)

  ;; Remove all distracting information from helm modeline
  (setq helm-mode-line-string "\\<helm-map>"
        helm-top-mode-line "\\<helm-top-map>"
        helm-comp-read-mode-line "\\<helm-comp-read-map>"
        helm-read-file-name-mode-line-string "\\<helm-read-file-map>")

  ;; Helm find files custom settings
  (setq helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-ff-file-name-history-use-recentf t ; add extra source with recently visited files
        helm-ff-delete-files-function #'helm-delete-marked-files-async) ; Delete files asynchronously without asking for confirmation

  ;; Remap built-in keybindings to use helm analogs
  (with-eval-after-load 'helm
    (define-key global-map [remap find-file] #'helm-find-files)
    (define-key global-map [remap occur] #'helm-occur)
    (define-key global-map [remap switch-to-buffer] #'helm-mini)
    (define-key global-map [remap dabbrev-expand] #'helm-dabbrev)
    (define-key global-map [remap execute-extended-command] #'helm-M-x)
    (define-key global-map [remap yank-pop] #'helm-show-kill-ring)

    (define-key lisp-interaction-mode-map [remap completion-at-point] #'helm-lisp-completion-at-point)
    (define-key emacs-lisp-mode-map       [remap completion-at-point] #'helm-lisp-completion-at-point)

    (define-key helm-find-files-map (kbd "C-i") #'helm-ff-TAB))

  ;; Use `display-buffer' function to show helm windows to control where they
  ;; appear using `display-buffer-alist'.
  (setq helm-display-function #'display-buffer)
  (setq helm-show-completion-display-function #'display-buffer)

  ;; Keep `helm-adaptive-history' in the dedicated folder
  (setq helm-adaptive-history-file (expand-file-name "helm-adaptive-history" rr-savefile-dir))

  ;; `helm-grep' custom settings. Mostly to fix colors.
  (setq helm-grep-default-command "grep --color=never -a -d skip %e -n%cH -e %p %f"
        helm-grep-git-grep-command "git --no-pager grep -n%cH --color=never --full-name -e %p -- %f"
        helm-grep-ag-command "rg --color=always --smart-case --no-heading --line-number %s %s %s")

  (helm-mode 1)
  (helm-adaptive-mode 1))
#+end_src

*** Helm flycheck

Show all flycheck errors in the current buffer using helm interface with all
power of helm (navigation and search).

#+begin_src emacs-lisp
(use-package helm-flycheck
  :after (helm flycheck)
  :config
  (eval-after-load 'flycheck
    '(define-key flycheck-mode-map (kbd "C-'") #'helm-flycheck)))
#+end_src

*** Helm flyspell correct

Correct spelling errors using helm interface.

#+begin_src emacs-lisp
(use-package flyspell-correct
  :after flyspell
  :config
  (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-wrapper))

(use-package flyspell-correct-helm
  :after flyspell-correct)
#+end_src

*** Helm org rifle

Quick navigation by org headings in ~org-agenda-files~ with helm interface. I
usually have org file opened and use ~imenu~ for navigation, so I don't use
this package.

#+begin_src emacs-lisp
(use-package helm-org-rifle
  :after helm
  :config
  (define-key global-map (kbd "C-x c o") #'helm-org-rifle-agenda-files))
#+end_src

*** Helm xref

Helm interface for ~xref~ package. Just install the package and it works
without any configuration.

#+begin_src emacs-lisp
(use-package helm-xref
  :after helm)
#+end_src

*** Helm lsp integration

Search through all workspace definitions provided by ~lsp-mode~ with helm
interface. Use it sometimes, the problem is for multiroot projects (for example
java) it can shows duplicated definitions from different projects which makes
it difficult to navigate to proper version.

#+begin_src emacs-lisp
(use-package helm-lsp
  :after helm
  :config
  (define-key global-map (kbd "C-x c j") #'helm-lsp-workspace-symbol))
#+end_src

*** Helm describe bindings

Very useful package, but I always forget about it. There is not to much cases
when I need to search through all available keybindings for the buffer.

The default keybinding is =C-h b=.

#+begin_src emacs-lisp
(use-package helm-descbinds
  :after helm
  :config
  (helm-descbinds-mode))
#+end_src

** COMMENT Ivy

This section is not maintained. I keep it here just for history.

*** Configuration

#+begin_src emacs-lisp
(use-package ivy
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-read-action-function #'ivy-read-action-ivy)

  (setq counsel-describe-variable-function #'helpful-variable
        counsel-describe-function-function #'helpful-function)

  (setq search-default-mode #'char-fold-to-regexp)

  ;; Key bindings
  (global-set-key (kbd "C-s") #'swiper-isearch)
  (global-set-key (kbd "C-c C-r") #'ivy-resume)
  (define-key global-map [remap occur] #'counsel-rg)
  (define-key global-map (kbd "C-h v") #'counsel-describe-variable)
  (define-key global-map (kbd "C-h f") #'counsel-describe-function)
  (global-set-key (kbd "M-x") #'counsel-M-x)
  (global-set-key (kbd "C-x C-f") #'counsel-find-file)
  (global-set-key (kbd "C-x j") #'counsel-semantic-or-imenu)
  (global-set-key (kbd "C-x b") #'ivy-switch-buffer)
  (global-set-key (kbd "M-y") #'counsel-yank-pop)
  (define-key minibuffer-local-map (kbd "C-r") #'counsel-minibuffer-history)

  (ivy-set-occur 'counsel-rg 'counsel-ag-occur)
  (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur)
  (ivy-set-occur 'swiper 'swiper-occur)
  (ivy-set-occur 'swiper-isearch 'swiper-occur)

  (setq ivy-height-alist
        '((counsel-evil-registers . 5)
          (counsel-yank-pop . 10)
          (counsel-el . 7)))

  (setq ivy-re-builders-alist
        '((counsel-rg . ivy--regex-or-literal)
          (t . ivy--regex-plus))))

(use-package counsel
  :after ivy
  :config
  (setq counsel-yank-pop-separator "\n——————————————————\n"))
#+end_src

*** Ivy rich

Add some fancy information to ivy minibuffer.

#+begin_src emacs-lisp
(use-package ivy-rich
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  (setq ivy-rich-path-style 'abbreviate)
  (ivy-rich-mode 1))
#+end_src

*** Posframe

#+begin_src emacs-lisp
(use-package ivy-posframe
  :config
  (setq ivy-posframe-display-functions-alist
      '((swiper          . nil)
        (complete-symbol . ivy-posframe-display-at-point)
        (t               . ivy-posframe-display-at-frame-center)))
  (ivy-posframe-mode 1))
#+end_src

*** Ivy xref

#+begin_src emacs-lisp
(use-package ivy-xref
  :config
  (setq xref-show-xrefs-function 'ivy-xref-show-xrefs)
  (setq xref-show-definitions-function #'ivy-xref-show-defs))
#+end_src

*** Smex

Better sorting for counsel/ivy

#+begin_src emacs-lisp
(use-package smex)
#+end_src

* In buffer automatic completion

** Company

The most powerful emacs auto-completion framework nowadays. Actively supported
and maintained, easy to setup.

I disabled it for some modes (mostly derived from ~text-mode~) and for shell
mode (because I use tab completion for shell).

#+begin_src emacs-lisp
(use-package company
  :config
  (setq company-global-modes '(not org-mode markdown-mode shell-mode))
  (setq company-tooltip-align-annotations t
        company-idle-delay .2)

  (global-company-mode)
  (company-tng-mode))
#+end_src

** Quick help

Good addition to ~company-mode~ which automatically shows documentation for
candidate in the separate pop-up window.

#+begin_src emacs-lisp
(use-package company-quickhelp
  :config
  (setq company-quickhelp-use-propertized-text t)
  (company-quickhelp-mode))
#+end_src

** COMMENT Show completion in posframe

Kind of /modern/ front-end for ~company-mode~ which shows candidates in the
~posframe~. It doesn't have some issues which the original front-end has
(broken layout when you have large fonts for example). I've tried it a few
times, it has some issues and performance is still worse than the original
front-end.

I hope one day it will be good enough to replace original one.

#+begin_src emacs-lisp
(use-package company-posframe
  :config
  (setq company-posframe-show-indicator nil
        company-posframe-quickhelp-show-header nil
        company-posframe-quickhelp-delay .5)
  (company-posframe-mode 1))
#+end_src

* Fixes and improvements

** Asynchronous processing in Emacs

Emacs is synchronous by default and has very limited multi-threading
support. This package makes some commands asynchronous.

#+begin_src emacs-lisp
(use-package async
  :config
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (setq async-bytecomp-allowed-packages 'all)
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1))
#+end_src

** Set the same PATH as in shell

Emacs doesn't pick up shell environment variables by default. This package
fixes it.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize))
#+end_src

** Misc-cmds

Small package with bunch of handy functions. I remap built-in ~quit-window~ to
~quit-window-delete~ which kill the buffer and make sure the window is
closed. The original one not always does it.

#+begin_src emacs-lisp
(use-package misc-cmds
  :config
  (define-key global-map [remap quit-window] 'quit-window-delete))
#+end_src

** Which key

Very handy package. Setup once and forget :)

Show keybindings in the minibuffer after pressing prefix key.

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+end_src

* Org-mode

One of the emacs killer features :)

Org-mode can do almost everything:
- Manage tasks and TODO lists
- Track time of tasks
- Execute source blocks and export source code blocks to files
- Schedule events, set deadlines and track them in the agenda buffer
- Literate programming
- Can be used as markup language
- Many more...

Org-mode has a lot of settings and it's possible to setup it any way you like.

Below some settings for UI and common behavior. All the modifications are
documented in the comment strings.

#+begin_src emacs-lisp
(use-package org
  :config
  ;; Set increased margins for all org mode buffers
  (add-hook 'org-mode-hook #'rr/set-margins)

  ;; Setup ui
  (setq org-adapt-indentation nil                                        ; Do not align content with headline level
        org-eldoc-breadcrumb-separator " → "                             ; Headline levels separator for ElDoc mode
        org-ellipsis "…"                                                 ; If headline has content and folded show this at the end of line
        org-hide-leading-stars t                                         ; Hide leading stars for subheading
        org-indent-mode-turns-on-hiding-stars t                          ; Enable hiding leading stars when `org-indent-mode' is active
        org-priority-faces '((?a . error) (?b . warning) (?c . success)) ; Faces for priority indicators
        org-tags-column 0                                                ; Place tags just after headline
        org-startup-folded 'content                                      ; Show all heading and subheading folded on open org file
        org-startup-indented nil                                         ; Disable `org-indent-mode' by default, I prefer to enable it file locally
        org-startup-shrink-all-tables t                                  ; Makes tables more compact by default
        org-edit-src-content-indentation 0                               ; Do not place additional indentation inside source blocks
        org-cycle-separator-lines 1                                      ; How many empty lines should be between headings to keep it in folded mode
        org-startup-with-inline-images nil                               ; Do not show images in org mode buffers by default
        org-display-remote-inline-images nil                             ; Do not download remote images
        org-hide-emphasis-markers nil                                    ; Show emphasis markers in org mode buffers, otherwise it will lead to align problems
        org-insert-heading-respect-content t                             ; Insert new headings after content and not after point
        org-fontify-done-headline t                                      ; Add special face for the entire done heading and not only keyword
        org-fontify-todo-headline t                                      ; Add special face for the entire todo heading and not only keyword
        org-src-fontify-natively t                                       ; Enable native syntax highlighting inside source code block
        org-image-actual-width 500                                       ; Limit maximum images width
        org-use-sub-superscripts '{}                                     ; Do not treat symbols after "_" as subscripts on export
        org-archive-subtree-save-file-p t                                ; Save archive file automatically after archive subtree is done
        org-table-header-line-p nil)                                     ; Do not activate `org-table-header-line-mode' by default

  (setq org-special-ctrl-a/e t                                           ; When you press `C-e' or `C-a' on heading navigation is more smart
        org-special-ctrl-k t                                             ; Kill the headline with all content on `C-k'
        org-ctrl-k-protect-subtree t                                     ; Protect from killing folded content
        org-imenu-depth 4                                                ; Maximum allowed level of heading which will be present in `imenu'
        org-export-with-sub-superscripts nil                             ; Avoid superscripts on export
        org-src-window-setup 'split-window-below                         ; When you edit source code block, the edit window will appear below current one
        org-catch-invisible-edits 'show-and-error                        ; If you try to edit folded or invisible area it will be unfolded and warning will be shown
        org-return-follows-link t                                        ; Open links just by pressing ENTER
        org-list-use-circular-motion t                                   ; Go through list levels circularly
        org-export-with-drawers t                                        ; Export drawers along with content
        org-export-with-properties t                                     ; Export properties along with content
        org-reverse-note-order t                                         ; Put new notes below old
        org-use-speed-commands t                                         ; Very useful setting, allow `org-speed-command'
        org-enforce-todo-dependencies t                                  ; Do not allow moving heading to DONE if it has subheading in TODO status
        org-enforce-todo-checkbox-dependencies t                         ; The same as above but for checkboxes
        )

  ;; Open different kind of links different way
  (setq org-link-frame-setup
        '((vm . vm-visit-folder-other-frame)
          (vm-imap . vm-visit-imap-folder-other-frame)
          (gnus . org-gnus-no-new-news)
          (file . find-file)
          (wl . wl-other-frame)))

  ;; Set keybinding to replace link with its description
  (define-key org-mode-map (kbd "C-c u") #'rr/org-replace-link-by-link-description)

  ;; Enable some modules
  (add-to-list 'org-modules 'org-notify)  ; Add support for notifications

  (eval-after-load 'org
    '(org-load-modules-maybe t)))
#+end_src

** Effort estimates

It's possible to put estimation to the headline and then track time of the
task.

The following settings define default time grid for task estimations and
columns for ~org-columns~ (this mode can be enabled by ~C-c C-x C-c~) with task
name, estimated effort and actual clocking time.

#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-global-properties '(("Effort_ALL" . "0 0:30 1:00 2:00 4:00 6:00 8:00 16:00")))
  (setq org-columns-default-format "%40ITEM(Task) %17Effort(Estimated Effort){:} %CLOCKSUM"))
#+end_src

** Agenda settings

Setup files which should be used by ~agenda-mode~ and some tweaks for agenda.

#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :after org
  :config
  ;; Set files which will be used for building agenda
  (setq org-agenda-files (quote ("~/Org/tasks/index.org"
                                 "~/Org/tasks/bsc.org"
                                 "~/Org/tasks/epam.org"
                                 "~/Org/tasks/personal.org"
                                 "~/Org/tasks/libertyglobal.org"
                                 "~/Org-mobile/home.org")))

  ;; Default org directory, don't think this setting changes something for my
  ;; setup
  (setq org-directory "~/Org")

  (setq org-agenda-restore-windows-after-quit t    ; Restore windows layout after quit agenda
        org-agenda-archives-mode t                 ; Include archived items into agenda
        org-agenda-start-with-clockreport-mode nil ; Do not activate `clockreport-mode' in agenda buffer
        org-agenda-start-with-log-mode t           ; Activate `log-mode' in agenda buffers
        org-agenda-window-setup 'only-window       ; Hide all other windows when open agenda
        org-agenda-span 'week                      ; Start agenda for week interval
        org-agenda-todo-ignore-scheduled 'future   ; Do not include future items to global TODO list
        org-agenda-show-future-repeats 'next       ; Show only first next repeating task in the agenda
        org-agenda-breadcrumbs-separator " → "     ; The separator of breadcrumbs in agenda lines
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-agenda-skip-timestamp-if-deadline-is-shown t
        )

  ;; Make time grid more detailed
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100)
          "......"
          "----------------"))

  ;; Set keybinding to easily switch to month view
  (define-key org-agenda-mode-map (kbd "C-c m") #'org-agenda-month-view))
#+end_src

** Org capture

Very powerful feature of org-mode, but I don't use it too much. One useful
thing here is capture links using emacs client. I bind ~make-capture-frame~
function to OS hotkey, which creates new emacs frame with org capture buffer.

#+begin_src emacs-lisp
(use-package org
  :config
  ;; Default file for org captures
  (setq org-default-notes-file (concat org-directory "/notes.org"))

  ;; Define some custom capture templates
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/Org/tasks/index.org" "Unsorted tasks")
           "* TODO %?\n%i")
          ("n" "Note" entry (file+headline "" "Notes")
           "* TODO %?\n%i")
          ("l" "Link" entry (file+headline "~/Org/links.org" "Links")
           "* %? %^L \n%T"
           :prepend t)))

  ;; Set max sub-level for refile org headings
  (setq org-refile-targets
        (quote ((nil :maxlevel . 6)
                (org-agenda-files :maxlevel . 6))))

  ;; The following was taken from one of Mike Zamansky videos
  (defadvice org-capture-finalize (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame."
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-destroy (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame."
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-select-template (around delete-capture-frame activate)
    "Advise org-capture-select-template to close the frame on abort."
    (unless (ignore-errors ad-do-it t)
      (setq ad-return-value "q"))
    (if (and
         (equal "q" ad-return-value)
         (equal "capture" (frame-parameter nil 'name)))
        (delete-frame)))

  (use-package noflet)

  (defun make-capture-frame ()
    "Create a new frame and run 'org-capture'."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture))))
#+end_src

** Tag list

I use tags for working tasks. Here I define possible tags, but it's always
possible to create new tags on the fly.

#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-tag-alist '(("@bug" . ?b) ("@task" . ?t) ("@story" . ?s))))
#+end_src

** Keywords list

Define my personal list of TODO keywords. Besides default I want to have some
additional statuses of tasks.

#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROGRESS(p)" "WAITING(w)" "REVIEW(r)" "|" "DONE(d)" "CANCELED(c@)"))))
#+end_src

** Mark task as DONE if all subtasks are DONE

Stolen from the org-mode documentation. Not sure whether it actually works.

#+begin_src emacs-lisp
(use-package org
  :config
  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

  (add-hook 'org-after-todo-statistics-hook #'org-summary-todo))
#+end_src

** Custom keywords faces

Maybe it's better to keep this in the [[*Appearance][appearance]] section, but so far I keep all
org-mode related settings together. I use colors directly from the color scheme.

#+begin_src emacs-lisp
(use-package org-faces
  :ensure nil
  :after (org zenburn-theme)
  :config
  ;; Modus vivendi
  ;; (modus-vivendi-theme-with-color-variables
  ;;   (setq org-todo-keyword-faces
  ;;         `(("PROGRESS" . (:inherit org-todo :foreground ,blue))
  ;;           ("WAITING" . (:inherit org-todo :foreground ,yellow))
  ;;           ("REVIEW" . (:inherit org-todo :foreground ,yellow))
  ;;           ("CANCELED" . (:inherit org-todo :foreground ,fg-alt)))))

  ;; Zenburn
  (zenburn-with-color-variables
    (setq org-todo-keyword-faces
          `(("PROGRESS" . (:inherit 'org-todo :foreground ,zenburn-blue))
            ("WAITING" . (:inherit org-todo :foreground ,zenburn-orange))
            ("REVIEW" . (:inherit org-todo :foreground ,zenburn-orange))
            ("CANCELED" .(:inherit org-todo :foreground ,zenburn-fg-1)))))

  ;; Tomorrow night
  ;; (let ((comment "#969896")
  ;;       (yellow "#f0c674")
  ;;       (aqua "#8abeb7"))
  ;;   (setq org-todo-keyword-faces
  ;;         `(("PROGRESS" . (:inherit 'org-todo :foreground ,aqua))
  ;;           ("WAITING" . (:inherit org-todo :foreground ,yellow))
  ;;           ("REVIEW" . (:inherit org-todo :foreground ,yellow))
  ;;           ("CANCELED" . (:inherit org-todo :foreground ,comment)))))
  )
#+end_src

** Extra Org-mode export packages

Org-mode documents can be exported to a various type of documents (PDF, HTML,
ODT etc.). Besides there are a lot of packages which provide support for export
to more specific formats or file types.

*** Slack export

Export org-mode buffer (or part of it) to markup compatible with slack messenger.

#+begin_src emacs-lisp
(use-package ox-slack)
#+end_src

*** Confluence export

Built into org-mode package but not enabled by default. Export org buffer to
markup compatible with atlassian confluence.

#+begin_src emacs-lisp
(require 'ox-confluence)
#+end_src

*** Markdown export

Also built into org-mode package and not enabled. That's obviously export org
mode buffer to markdown.

#+begin_src emacs-lisp
(require 'ox-md nil t)
(eval-after-load 'org
  '(require 'ox-gfm nil t))
#+end_src

*** LaTeX export

Org-mode buffer can be exported to PDF using LaTeX. Here I define custom
templates. To use it special header should be included to org document.

#+begin_example
#+LATEX_CLASS: org-article-en
#+LATEX_CLASS: org-article
#+end_example

One of them for documents which contains Russian letters, second for those
which doesn't.

#+begin_src emacs-lisp
(require 'ox-latex)
(setq org-latex-inputenc-alist '(("utf8" . "utf8x")))
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc"  t ("pdflatex"))
        (""     "graphicx"  t)
        (""     "grffile"   t)
        (""     "longtable" nil)
        (""     "wrapfig"   nil)
        (""     "rotating"  nil)
        ("normalem" "ulem"  t)
        (""     "amsmath"   t)
        (""     "textcomp"  t)
        (""     "amssymb"   t)
        (""     "capt-of"   nil)
        (""     "hyperref"  nil)))
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))

(add-to-list 'org-latex-classes
             '("org-article"
               "\\documentclass[11pt,a4paper]{article}
\\usepackage[sfdefault]{noto}
\\usepackage{sourcecodepro}
\\usepackage[T2A]{fontenc}
\\usepackage[english, russian]{babel}
\\usepackage[hidelinks]{hyperref}
\\usepackage{geometry}
\\geometry{a4paper}
\\geometry{left=2cm,right=1cm,top=1cm,bottom=1cm,includeheadfoot,headheight=1.2cm}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
             '("org-article-en"
               "\\documentclass[11pt,a4paper]{article}
\\usepackage[default]{sourcesanspro}
\\usepackage{sourcecodepro}
\\usepackage[T1]{fontenc}
\\usepackage[english]{babel}
\\usepackage[hidelinks]{hyperref}
\\usepackage{geometry}
\\geometry{a4paper}
\\geometry{left=2cm,right=1cm,top=1cm,bottom=1cm,includeheadfoot,headheight=1.2cm}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

*** JIRA export

Third party package. Export org-mode buffer to paste to JIRA ticket
description. Not perfect, some markup should be fixed after pasting.

#+begin_src emacs-lisp
(use-package ox-jira
  :config
  (defun rr/replace-org-with-jira-markup (_frame)
    (remove-hook 'delete-frame-functions #'rr/replace-org-with-jira-markup)
    (let ((markup-text (org-export-as 'jira)))
      (erase-buffer)
      (insert markup-text)))

  (setq org-export-copy-to-kill-ring 'if-interactive))
#+end_src

** Notifications

To show notifications from the org mode I use built-in ~appt~ package along
with ~notifications~. On some events (once a day, after saving org mode file
which is part of agenda files, on startup) I save scheduled org mode entities
of with set deadlines to appointment. 15 minutes before scheduled event OS
notification will be shown.

#+begin_src emacs-lisp
(use-package appt
  :ensure nil
  :after (notifications org)
  :config
  (appt-activate t)
  (setq appt-message-warning-time 15) ; Show notification 15 minutes before event
  (setq appt-display-mode-line nil)   ; Don't show anything in mode line

  ;; Use appointment data from org-mode
  (defun rr/org-agenda-to-appt ()
    (interactive)
    (setq appt-time-msg-list nil)
    (org-agenda-to-appt))

  (defun rr/format-minutes (min-rest)
    "Format minutes for notification."
    (cond ((equal "0" min-rest) "Now.")
          ((equal "1" min-rest) (format "In %s minute." min-rest))
          (t (format "In %s minutes." min-rest))))

  (defun rr/show-appt-notification (min-to-app new-time appt-msg)
    "Show notifications function."
    (let ((mins-to-app (if (listp min-to-app)
                           min-to-app
                         (list min-to-app)))
          (appt-msgs (if (listp appt-msg)
                         appt-msg
                       (list appt-msg))))
      (let ((msgs (mapcar* #'cons appt-msgs mins-to-app)))
        (dolist (msg msgs)
          (let ((title (car msg))
                (min-rest (cdr msg)))
            (notifications-notify :title title
                                  :timeout (if (equal min-rest "0") 0 -1)
                                  :body (format "%s\n%s"
                                                (rr/format-minutes min-rest)
                                                new-time)))))))

  ;; Update after emacs start
  (add-hook 'after-init-hook #'rr/org-agenda-to-appt)

  ;; Every day at 0:05
  (run-at-time "0:05" (* 24 3600) #'rr/org-agenda-to-appt)

  (add-hook 'after-save-hook
            (lambda ()
              (if (org-agenda-file-p (buffer-file-name))
                  (rr/org-agenda-to-appt))))

  (setq appt-disp-window-function #'rr/show-appt-notification)
  (setq appt-delete-window-function (lambda () t))
  (setq org-show-notification-handler #'notifications-notify))
#+end_src

** Unset conflicting keybindings

This keybinding conflicts with ~eyebrowse~ default prefix and I don't use it in
org-mode, so I unbind it.

#+begin_src emacs-lisp
(use-package org-table
  :ensure nil
  :after org
  :config
  (define-key orgtbl-mode-map (kbd "C-c C-w") nil))
#+end_src

** Org clock

I use org clocking a lot to track how much time I've spent on particular
task. I don't set status of TODO headlines directly through ~org-todo~
command.

Short description of my flow:
- I execute ~org-clock-in~ and the task moves to =PROGRESS= status
  automatically.
- When I execute ~org-clock-out~ I'm getting the prompt to which state should I
  set the headline.
- If I have clocking headline and I execute ~org-clock-in~ on another headline,
  I'm getting the prompt to which status should I set the previously clocked
  headline.

I prefer to have persistent clocking between emacs sessions to not lose any
statistics. Some settings described in the comment strings.

#+begin_src emacs-lisp
(use-package org-clock
  :ensure nil
  :after org
  :config
  (setq org-clock-persist-file (expand-file-name "org-clock-save.el" rr-savefile-dir) ; Keep saved clock state in separate file
        org-log-into-drawer t                                                         ; Put clocking information into drawers
        org-log-done nil                                                              ; Do not add separate entry to log when task is done
        org-log-repeat nil                                                            ; Keep org files clear and do not include extra logging
        org-log-redeadline 'time                                                      ; Id deadline has changed write time for this event
        org-log-reschedule 'time                                                      ; The same as above but for scheduled tasks
        org-clock-out-when-done t                                                     ; Move to DONE on `org-clock-out'
        org-clock-in-resume t                                                         ; If task has opened clock, resume clock from the last point
        org-clock-out-remove-zero-time-clocks t                                       ; Remove clocking entries if duration less that 1 minute
        org-clock-report-include-clocking-task t                                      ; Include currently clocked tasks to clock report
        org-clock-persist-query-resume nil                                            ; Do not ask to restore clock on emacs startup
        org-clock-persist t                                                           ; Restore clock after restart emacs
        )

  ;; Automatically move task to PROGRESS status on `org-clock-in'
  (setq org-clock-in-switch-to-state "PROGRESS")

  (defvar non-clocking-states '("WAITING" "REVIEW" "DONE" "TODO" "CANCELED")
    "New state for current clocking task.")

  (defun rr/read-non-clocking-state ()
    "Prompt to select non-clocking state."
    (interactive)
    (message "%s" (completing-read "Select state: " non-clocking-states)))

  (defun rr/after-clock-stop (last)
    "Change TASK state after clock stop depends on LAST state."
    (when (not (or (string-equal last "WAITING")
                   (string-equal last "DONE")
                   (string-equal last "REVIEW")
                   (string-equal last "TODO")
                   (string-equal last "CANCELED")))
      (rr/read-non-clocking-state)))

  ;; On `org-clock-out' ask which status move the headline to
  (setq org-clock-out-switch-to-state #'rr/after-clock-stop)

  ;; Restore clock on emacs startup
  (org-clock-persistence-insinuate))
#+end_src

** Org-mime

Convert org-mode buffer to nice looking HTML. On of the use cases is emails
with HTML markup.

#+begin_src emacs-lisp
(use-package org-mime
  :config
  (define-key message-mode-map (kbd "C-c M-o") #'org-mime-htmlize)
  (define-key org-mode-map (kbd "C-c M-o") #'org-mime-org-buffer-htmlize)

  (add-hook 'org-mime-html-hook
            (lambda ()
              (org-mime-change-element-style
               "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                             "#DCDCCC" "#3F3F3F"))))

  ;; the following can be used to nicely offset block quotes in email bodies
  (add-hook 'org-mime-html-hook
            (lambda ()
              (org-mime-change-element-style
               "blockquote" "border-left: 2px solid gray; padding-left: 4px;")))

  (setq org-mime-export-options
        '(:section-numbers nil :with-author nil :with-toc nil)))
#+end_src

** Handle local file links by extension

Open links to different type of files in the different way.

#+begin_src emacs-lisp
(use-package org
  :config
  (setq org-file-apps
        '((auto-mode . emacs)
          ("\\.x?html\\'" . "firefox %s")
          ("\\(?:xhtml\\|html\\)\\'" . "firefox %s")
          ("\\.mm\\'" . default)
          ("\\.pdf\\'" . default))))
#+end_src

** Evaluate source code

As I mentioned before org mode is able to execute source code blocks and can be
used for literate programming. Below I define which languages can be used for
~org-babel~ package.

#+begin_src emacs-lisp
(use-package ob-core
  :ensure nil
  :after org
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (sql . t)
     (shell . t)
     (sqlite . t)
     (haskell . t)
     (clojure . t)
     (ditaa . t)
     (plantuml . t)))

  (setq org-confirm-babel-evaluate t
        org-export-use-babel nil))
#+end_src

Set custom path to =ditaa.jar=.

#+begin_src emacs-lisp
(use-package ob-ditaa
  :ensure nil
  :config
  (setq org-ditaa-jar-path "~/Soft/ditaa/ditaa.jar"))
#+end_src

Add support for asynchronous execution of source code blocks.

#+begin_src emacs-lisp
(use-package ob-async)
#+end_src

** Poporg

Edit program comments and strings using Org-mode. I don't use it because I
don't write a lot of docstrings and when I write it I forget about this
package. But the idea is nice and probably one day I'm gonna use it more
often.

#+begin_src emacs-lisp
(use-package poporg)
#+end_src

* Org-roam

I've been looking forward to try this package to figure out what is it and what
is it for. Finally I've found time for it.

#+begin_src emacs-lisp
(use-package org-roam
  :config
  (setq org-roam-directory "~/Org-roam")
  (add-hook 'after-init-hook #'org-roam-mode)
  (define-key org-roam-mode-map (kbd "C-c n l") #'org-roam)
  (define-key org-roam-mode-map (kbd "C-c n f") #'org-roam-find-file)
  (define-key org-roam-mode-map (kbd "C-c n g") #'org-roam-graph)
  (define-key org-mode-map (kbd "C-c n i") #'org-roam-insert)
  (define-key org-mode-map (kbd "C-c n I") #'org-roam-insert-immediate))
#+end_src

* Virtual workspace

To simulate the workspace behavior I use [[https://depp.brause.cc/eyebrowse/][eyebrowse]] package. One good
alternative which I also used to use is [[https://github.com/nex3/perspective-el][perspective.el]] but I found it to strict
regarding buffer list per workspace. Another alternative is ~tab-line-mode~ or
~tab-bar-mode~ which are included into emacs since version 27.1. The
functionality is the same but tabs itself are space-consuming and I prefer to
have small indicators in the mode line.

The configuration is pretty straightforward and the package works well out of
the box.

#+begin_src emacs-lisp
(use-package eyebrowse
  :config
  (setq eyebrowse-wrap-around t
        eyebrowse-new-workspace t
        eyebrowse-switch-back-and-forth t
        eyebrowse-mode-line-style 'always)
  (eyebrowse-mode t))
#+end_src

* Windows navigation

I was looking for quick way to navigate between windows and found winum the
best option for me. I've bound navigation to the =C-<number>= keybinding. Each
window has indicator in the mode line with the number which should be used for
navigation.

#+begin_src emacs-lisp
(use-package winum
  :init
  (setq winum-keymap
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-`") #'winum-select-window-by-number)
          (define-key map (kbd "C-²") #'winum-select-window-by-number)
          (define-key map (kbd "M-0") #'winum-select-window-0-or-10)
          (define-key map (kbd "M-1") #'winum-select-window-1)
          (define-key map (kbd "M-2") #'winum-select-window-2)
          (define-key map (kbd "M-3") #'winum-select-window-3)
          (define-key map (kbd "M-4") #'winum-select-window-4)
          (define-key map (kbd "M-5") #'winum-select-window-5)
          (define-key map (kbd "M-6") #'winum-select-window-6)
          (define-key map (kbd "M-7") #'winum-select-window-7)
          (define-key map (kbd "M-8") #'winum-select-window-8)
          map))
  :config
  (setq winum-auto-setup-mode-line t
        winum-ignored-buffers '(" *which-key*"))
  (winum-mode))
#+end_src

* Version control

Emacs has built-in support for various version control systems by means of
~vc-mode~. Some third-party packages relies on this mode and some don't. This
section contains all the packages related to work with version control systems
inside of emacs.

** Magit

I used to use only command line interface for git. Not I use only magit. It has
everything I need for work with git. Here is not too much customization because
default behavior fit perfectly into my needs.

#+begin_src emacs-lisp
(use-package magit
  :config
  (setq magit-revision-use-hash-sections 'quick
        magit-pull-or-fetch t)

  (add-hook 'magit-post-refresh-hook #'rr/refresh-vc-state 5))
#+end_src

The settings below for the diff buffers produced by Magit. By default it
doesn't highlight changes inside the line. It's still in testing for me,
probably I won't like it and disable in the future.

#+begin_src emacs-lisp
(use-package magit-diff
  :ensure nil
  :after magit
  :config
  (setq magit-diff-refine-hunk nil))
#+end_src

** Transient

This package used to be part of Magit package, but now it's moved to separate
package. It provides pop-up menu to execute commands with single keypress and
support some additional options.

#+begin_src emacs-lisp
(use-package transient
  :config
  (setq transient-show-popup t))
#+end_src

** Forges

Very interesting package, which adds support work with git forges (like GitHub,
Gitlab etc.). Actually this package supports good only GitHub and Gitlab, I use
Bitbucket at work so I don't have a chance to estimate full power of this
package, but looks impressive.

#+begin_src emacs-lisp
(use-package forge)
#+end_src

** Diff highlight

Highlights uncommitted changes on the side of the window (using the fringe, by
default), allows you to jump between the hunks and revert them selectively.

#+begin_src emacs-lisp
(use-package diff-hl
  :init
  (global-diff-hl-mode)
  :config
  (setq diff-hl-draw-borders nil
        diff-hl-side 'right)
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh 3))
#+end_src

** Magit TODOs

Show TODO items from the entire repo in magit buffer.

#+begin_src emacs-lisp
(use-package magit-todos
  :config
  (add-hook 'prog-mode-hook #'magit-todos-mode))
#+end_src

** Gitignore templates

Insert template for =.gitignore= file at point.

#+begin_src emacs-lisp
(use-package gitignore-templates)
#+end_src

* Projects management

To manage projects in emacs I use projectile. It allows to perform many project
specific operations:
- Search inside project
- Run some commands in the root of project
- Build/test/compile project
- Open shell/eshell/terminal for current project
- switch between projects
- And many more...

Since version 27.1 emacs has built-in ~project.el~ module which is probably a
replacement for projectile, but I think projectile is more powerful and fit
perfectly into my needs.

** Projectile

Basic settings for =projectile=. It used to have prefix key =C-c p= by default
but now it has =C-c C-p= which conflicts with some bindings for other modes, so
I've changed prefix to the old value.

#+begin_src emacs-lisp
(use-package projectile
  :init
  (setq projectile-keymap-prefix (kbd "C-c p"))
  :config
  (setq projectile-completion-system 'helm
        ;; projectile-completion-system 'ivy
        projectile-sort-order 'recently-active
        projectile-mode-line-function (lambda ()
                                        (format " Proj[%s]" (projectile-project-name))))
  (add-to-list 'projectile-globally-ignored-files "*.log")
  (projectile-mode +1))
#+end_src

** Helm projectile

Nice addition to default projectile package. This package introduces some
useful commands which use helm interface for search and navigation.

#+begin_src emacs-lisp
(use-package helm-projectile
  :config
  (setq projectile-switch-project-action #'helm-projectile)
  (setq helm-projectile-truncate-lines t)
  (helm-projectile-on))
#+end_src

** COMMENT Counsel projectile

In case I will ever switch to ivy/swiper/counsel here is an alternative to
=helm-projectile= which uses ivy interface. Less powerful but still better than
default one.

#+begin_src emacs-lisp
(use-package counsel-projectile
  :config
  (counsel-projectile-mode))
#+end_src

* Work with text and navigation inside buffer

Here I'll keep useful packages which not related to programming modes directly
and can be helpful when you need to edit and navigate inside buffer.

** Smartparens

Keep the parenthesis balanced. This is applicable mostly to programming modes
but still can be used with plain text.

#+begin_src emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :config
  (setq sp-show-pair-from-inside nil
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil
        sp-wrap-respect-direction nil
        sp-navigate-interactive-always-progress-point t)

  (sp-with-modes 'web-mode
    (sp-local-pair "%" "%" :wrap "C-%")
    (sp-local-pair "<" ">" :wrap "C->"))

  (define-key smartparens-mode-map (kbd "C-c (") #'sp-wrap-round)
  (define-key smartparens-mode-map (kbd "C-c {") #'sp-wrap-curly)
  (define-key smartparens-mode-map (kbd "C-c [") #'sp-wrap-square)
  (define-key smartparens-mode-map (kbd "M-]") #'sp-unwrap-sexp)

  (define-key smartparens-mode-map (kbd "C-(") #'sp-backward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "C-)") #'sp-forward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "C-}") #'sp-forward-barf-sexp)
  (define-key smartparens-mode-map (kbd "C-{") #'sp-backward-barf-sexp)
  (define-key smartparens-mode-map (kbd "C-M-t") #'sp-transpose-sexp)
  (define-key smartparens-mode-map (kbd "C-M-k") #'sp-kill-sexp)
  (define-key smartparens-mode-map (kbd "C-M-f") #'sp-forward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-b") #'sp-backward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-a") #'sp-beginning-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-e") #'sp-end-of-sexp)

  (define-key smartparens-strict-mode-map [remap c-electric-backspace] #'sp-backward-delete-char)
  (define-key smartparens-strict-mode-map [remap c-electric-delete-forward] #'sp-delete-char)

  (sp-local-pair 'prog-mode "{" nil :post-handlers '(("||\n[i]" "RET")))
  (sp-local-pair 'prog-mode "[" nil :post-handlers '(("||\n[i]" "RET")))
  (sp-local-pair 'prog-mode "(" nil :post-handlers '(("||\n[i]" "RET")))
  (sp-local-pair 'java-mode "/*" "*/" :post-handlers '(("* ||\n[i]" "RET")))

  (add-hook 'eshell-mode-hook #'smartparens-strict-mode)

  (smartparens-global-strict-mode t)
  (show-smartparens-global-mode t))
#+end_src

** Multiple cursors

Very useful tool. You can put many cursors in the different places of buffer
and edit different part of buffer simultaneously. Has some helpful functions to
choose the proper places where to put cursors.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :bind
  (("C-S-c C-S-c" . mc/edit-lines)
   ("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c C-<" . mc/mark-all-like-this)
   ("C-c d" . mc/skip-to-next-like-this)))
#+end_src

** Expand region

Increases the selected region by semantic units. Just keep pressing the key
until it selects what you want.

#+begin_src emacs-lisp
(use-package expand-region
  :config
  (global-set-key (kbd "C-=") #'er/expand-region))
#+end_src

* Search and grep utilities

** Wgrep

Writable grep. After searching you can edit results of search directly and
write changes to all affected files.

#+begin_src emacs-lisp
(use-package wgrep
  :commands wgrep
  :config
  (setq wgrep-auto-save-buffer t))
#+end_src

*** Wgrep-ag

Allow ~wgrep~ for results of ~the_silver_searcher~ results.

#+begin_src emacs-lisp
(use-package wgrep-ag)
#+end_src

** the_silver_searcher (ag)

Emacs interface for [[https://github.com/ggreer/the_silver_searcher][the_silver_searcher]] grep tool. I don't use it directly but
I have it installed to be able to use =helm-ag= functionality.

#+begin_src emacs-lisp
(use-package ag :after wgrep-ag)
#+end_src

** Ripgrep

Different interfaces for [[https://github.com/BurntSushi/ripgrep][ripgrep]] tool for Emacs. There are 2 great packages:

- deadgrep
- rg

I've tried both. Both have their own pros and cons but both are great.

*** rg

Currently use it because it has global keybinding.

#+begin_src emacs-lisp
(use-package rg
  :config
  (setq rg-group-result t
        rg-hide-command t
        rg-show-columns nil
        rg-show-header t
        rg-custom-type-aliases nil
        rg-default-alias-fallback "all")
  (rg-enable-default-bindings))
#+end_src

*** Deadgrep

#+begin_src emacs-lisp
(use-package deadgrep)
#+end_src

** Helm interface for grep tools

I'm not sure I need it. I don't use this packages directly, but usually I use
corresponding =projectile= commands which provide helm interface to search
across the project files using =ag= or =rg=.

#+begin_src emacs-lisp
(use-package helm-ag)
(use-package helm-rg)
#+end_src

* Programming

** YASnippet

#+begin_quote
YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates.
#+end_quote

#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (setq yas-indent-line 'fixed
        yas-inhibit-overlay-modification-protection t)

  (yas-reload-all)
  (add-hook 'prog-mode-hook #'yas-minor-mode)
  (add-hook 'tex-mode-hook #'yas-minor-mode)

  ;; Expand and navigate between items by `C-j' to prevent conflicts with `company-tng'
  (define-key yas-minor-mode-map "\C-j" 'yas-expand)
  (define-key yas-keymap "\C-j" 'yas-next-field-or-maybe-expand)
  (dolist (keymap (list yas-minor-mode-map yas-keymap))
    (define-key keymap (kbd "TAB") nil)
    (define-key keymap [(tab)] nil)))
#+end_src

** Rainbow delimiters

Allows to distinguish different levels of nested delimiters by coloring them to
different colors.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :config
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

** Smartscan

Navigate between symbol occurrences by pressing =M-n= and =M-p=.

#+begin_src emacs-lisp
(use-package smartscan
  :config
  (setq smartscan-symbol-selector "symbol")
  (add-hook 'prog-mode-hook #'smartscan-mode))
#+end_src

** Rainbow mode

Colorize color names in buffers. Quite handy when you work with CSS of color
themes.

#+begin_src emacs-lisp
(use-package rainbow-mode
  :config
  (add-to-list 'rainbow-x-colors-major-mode-list #'web-mode)
  (add-to-list 'rainbow-x-colors-major-mode-list #'python-mode)
  (add-to-list 'rainbow-x-colors-major-mode-list #'emacs-lisp-mode))
#+end_src

** Auto set indentation settings

Useful if you have to work in the repository with different indentation
settings. It determines indentation level and set proper value per
buffer/file.

#+begin_src emacs-lisp
(use-package dtrt-indent
  :config
  (setq dtrt-indent-verbosity 0)
  (add-hook 'prog-mode-hook #'dtrt-indent-mode))
#+end_src

** Highlight TODO item

Highlight number of special text items (like =TODO=, =FIXME= etc.) with a
special face and allows to navigate between them or show list in the =occur=
buffer.

#+begin_src emacs-lisp
(use-package hl-todo
  :config
  (global-hl-todo-mode))
#+end_src

** Syntax check

Emacs has built-in module for show syntax errors - =flymake=. In version 26.1
it was rewritten and redesigned and should be useful now, but flycheck has more
plugins and integration with linters. So far I use flycheck.

*** Flycheck

Enable flycheck globally.

#+begin_src emacs-lisp
(use-package flycheck
  :config
  (setq flycheck-idle-change-delay 2
        flycheck-check-syntax-automatically '(save new-line mode-enabled))
  (setq flycheck-indication-mode 'left-fringe)

  (add-hook 'after-init-hook #'global-flycheck-mode))
#+end_src

And disable flymake autoload:

#+begin_src emacs-lisp
(use-package flymake
  :commands flymake-mode)
#+end_src

*** Show errors in posframe

I like the idea to see error message at point in the posframe. This package
implements it. I use it even for =lsp-mode= which by default uses =lsp-ui= for
showing error messages.

#+begin_src emacs-lisp
(use-package flycheck-posframe
  :config
  (with-eval-after-load 'flycheck
    (require 'flycheck-posframe)
    (setq flycheck-posframe-border-width 1
          flycheck-posframe-position 'window-bottom-left-corner)
    (add-hook 'flycheck-mode-hook #'flycheck-posframe-mode)))
#+end_src

** Auto insert

Insert default file templates automatically when create new file.

When I create new java source file I want to insert default class template
automatically.

#+begin_src emacs-lisp
(use-package autoinsert
  :ensure nil
  :after yasnippet
  :config
  (setq auto-insert-query nil)
  (setq auto-insert-directory (expand-file-name "templates/" user-emacs-directory))
  (add-hook 'find-file-hook #'auto-insert)
  (auto-insert-mode 1)

  (add-to-list 'auto-insert-alist
               '("\\.java" . ["default-java.el"
                              (lambda () (yas-expand-snippet
                                          (buffer-string)
                                          (point-min)
                                          (point-max)))])))
#+end_src

** Code folding

Code folding support based on =outline-mode=. I don't use it too much despite
it works pretty good.

#+begin_src emacs-lisp
(use-package origami
  :config
  (add-hook 'prog-mode-hook 'origami-mode)
  (define-key origami-mode-map [C-tab] #'origami-recursively-toggle-node))
#+end_src

** Google c-style

Fixes some code formatting and indentation problems in modes derived from
=c-mode=. One of the /install and forget/ packages.

#+begin_src emacs-lisp
(use-package google-c-style
  :config
  (add-hook 'c-mode-common-hook #'google-set-c-style)
  (add-hook 'c-mode-common-hook #'google-make-newline-indent))
#+end_src

** Treemacs

Tree-style directory browser for emacs. I don't really use it, I use helm for
navigation, but =lsp-mode= has some useful integration with treemacs (show call
hierarchy, show list of dependencies etc.) so I have to keep it as
dependency. I don't need all those fancy icons, so I disable it.

#+begin_src emacs-lisp
(use-package treemacs
  :after lsp-mode
  :config
  (define-key lsp-mode-map (kbd "C-c *") #'treemacs)
  (setq treemacs-no-png-images t
        treemacs-width 70
        treemacs-follow-after-init t
        treemacs-project-follow-cleanup t))
#+end_src

*** Treemacs LSP

As I mentioned before I have treemacs only for LSP integration. Here is some
settings for this package.

#+begin_src emacs-lisp
(use-package lsp-treemacs
  :after (treemacs lsp-mode)
  :config
  (lsp-treemacs-sync-mode 1)
  (define-key rr-lsp-keymap (kbd "h") #'lsp-treemacs-call-hierarchy))
#+end_src

** LSP

Great mode which implements client for Microsoft Language Server protocol. By
default has a lot of distracting UI features enabled from [[https://github.com/emacs-lsp/lsp-ui][lsp-ui]] package. I
don't use it and try to disable as much as possible distracting behavior.

Some settings below set to default values explicitly. It's either because I've
experimented with those settings or to prevent unpredictable behavior in case
default value is changed (the project's development is very active).

#+begin_src emacs-lisp
(use-package lsp-mode
  :config
  (define-key lsp-mode-map (kbd "C-c j") rr-lsp-keymap)
  (define-key rr-lsp-keymap (kbd "a") #'lsp-execute-code-action)
  (define-key rr-lsp-keymap (kbd "i") #'lsp-find-implementation)
  (define-key rr-lsp-keymap (kbd "r") #'lsp-rename)
  (define-key rr-lsp-keymap (kbd "d") #'lsp-describe-thing-at-point)

  (setq lsp-signature-auto-activate t
        lsp-signature-render-documentation nil
        lsp-file-watch-threshold 2000
        lsp-imenu-sort-methods '(kind position)
        lsp-modeline-diagnostics-enable nil
        lsp-modeline-code-actions-enable nil
        lsp-enable-on-type-formatting nil
        lsp-enable-indentation nil
        lsp-modeline-diagnostics-scope :file
        lsp-diagnostic-clean-after-change t
        lsp-completion-use-last-result t
        lsp-log-max 10000
        lsp-enable-snippet t)

  (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\.allure$")

  ;; Rust lsp settings
  (require 'lsp-rust)
  (setq lsp-rust-clippy-preference "on")
  (add-hook 'rust-mode-hook #'lsp)

  ;; Python lsp settings
  (require 'lsp-pyls)
  (setq lsp-pyls-plugins-pylint-enabled t
	      lsp-pyls-plugins-rope-completion-enabled nil
	      lsp-pyls-plugins-jedi-completion-enabled t
	      lsp-pyls-plugins-jedi-completion-include-params nil
	      lsp-pyls-plugins-jedi-signature-help-enabled t)
  (add-hook 'python-mode-hook #'lsp))
#+end_src

** DAP

Emacs client for Microsoft Debug Adapter Protocol. I have some custom functions
to run test method/test class at point using maven failsafe plugin (I use it
for work and probably it won't be helpful for anybody else).

#+begin_src emacs-lisp
(use-package dap-mode
  :after (lsp-java s)
  :config
  (dap-mode 1)
  (dap-ui-mode 1)

  (setq dap-java-test-runner (expand-file-name (locate-user-emacs-file ".cache/lsp/eclipse.jdt.ls/test-runner/junit-platform-console-standalone.jar")))
  (setq dap-auto-show-output nil)
  (setq dap-auto-configure-features '(locals))

  (require 'dap-lldb)
  (require 'dap-java)

  (define-key rr-lsp-keymap (kbd "t") #'dap-java-run-test-method)
  (define-key rr-lsp-keymap (kbd "c") #'dap-java-run-test-class)
  (define-key rr-lsp-keymap (kbd "b") #'dap-breakpoint-toggle)
  (define-key rr-lsp-keymap (kbd ";") #'dap-hydra)
  (define-key rr-lsp-keymap (kbd "e s") #'dap-eval-thing-at-point)
  (define-key rr-lsp-keymap (kbd "e r") #'dap-eval-region)
  (define-key rr-lsp-keymap (kbd "e e") #'dap-eval)

  ;; (add-hook 'dap-stopped-hook
  ;;           (lambda (arg) (call-interactively #'dap-hydra)))

  ;; Run build with args:
  ;; -Dmaven.failsafe.debug="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=1044 -Xnoagent"
  (require 'seq)
  (require 's)

  (defun rr/find-test-module ()
    (let* ((project-root (projectile-project-root))
           (modules (seq-filter
                     (lambda (dir) (or (s-suffix? "-tests" dir)
                                       (s-suffix? "-test" dir)))
                     (directory-files project-root))))
      (if (seq-empty-p modules)
          (error "Test module not found")
        (first modules))))

  (defun rr/debug-test (test-name)
    "Debug java test class or method depends on TEST-NAME."
    (let* ((dap-connect-retry-interval 0.5)
           (dap-connect-retry-count 1200)
           (port "1044")
           (current-workdir (projectile-project-root))
           (test-module (rr/find-test-module))
           ;; (project-name (file-name-nondirectory (directory-file-name current-workdir)))
           (command (format "mvn clean -Dit.test=%s verify -pl %s -P tests-for-development -Dmaven.failsafe.debug=\"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=%s -Xnoagent\"" test-name test-module port)))
      (dap-debug
       (list :type "java"
             :request "attach"
             :hostName "localhost"
             :port port
             :wait-for-port t
             :program-to-start command
             :name test-name
             :cwd current-workdir))))

  (defun rr/debug-test-ci-stage (test-name)
    "Debug java test class or method depends on TEST-NAME with ci-stage profile."
    (let* ((dap-connect-retry-interval 0.5)
           (dap-connect-retry-count 1200)
           (port "1044")
           (current-workdir (projectile-project-root))
           ;; (project-name (file-name-nondirectory (directory-file-name current-workdir)))
           (command (format "mvn clean -Dit.test=%s verify -Dci-stage=integration-tests -Dmaven.failsafe.debug=\"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=%s -Xnoagent\"" test-name port)))
      (dap-debug
       (list :type "java"
             :request "attach"
             :hostName "localhost"
             :port port
             :wait-for-port t
             :program-to-start command
             :name test-name
             :cwd current-workdir))))

  (defun rr/run-test (test-name)
    "Run java test class or method depends on TEST-NAME."
    (let ((default-directory (projectile-project-root))
          (test-module (rr/find-test-module)))
      (compilation-start (format "mvn clean -Dit.test=%s verify -pl %s -P tests-for-development" test-name test-module))))

  (defun rr/run-test-ci-stage (test-name)
    "Run java test class or method depends on TEST-NAME with ci-stage profile."
    (let ((default-directory (projectile-project-root)))
      (compilation-start (format "mvn clean -Dit.test=%s verify -Dci-stage=integration-tests" test-name))))

  (defun rr/run-test-method ()
    (interactive)
    (rr/run-test (dap-java-test-method-at-point)))

  (defun rr/run-test-method-ci-stage ()
    (interactive)
    (rr/run-test-ci-stage (dap-java-test-method-at-point)))

  (defun rr/run-test-class ()
    (interactive)
    (rr/run-test (dap-java-test-class)))

  (defun rr/run-test-class-ci-stage ()
    (interactive)
    (rr/run-test-ci-stage (dap-java-test-class)))

  (defun rr/debug-test-mehtod ()
    (interactive)
    (rr/debug-test (dap-java-test-method-at-point)))

  (defun rr/debug-test-method-ci-stage ()
    (interactive)
    (rr/debug-test-ci-stage (dap-java-test-method-at-point)))

  (defun rr/debug-test-class ()
    (interactive)
    (rr/debug-test (dap-java-test-class)))

  (defun rr/debug-test-class-ci-stage ()
    (interactive)
    (rr/debug-test-ci-stage (dap-java-test-class))))
#+end_src

** Languages and major modes

Programming, text editing, configuration files editing modes etc. Handy
packages to speed-up development for some languages. Language specific
packages.

*** Markdown mode

Usually I use org-mode as markup language. The most of forges support org-mode
syntax and can render org documents very nice way. But sometimes when I need to
contribute to some existing repository I have to deal with markdown. Here are
some settings for third party =markdown-mode= package.

#+begin_src emacs-lisp
(use-package markdown-mode
  :config
  (setq markdown-fontify-code-blocks-natively t)
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-hook 'markdown-mode-hook #'rr/set-margins))
#+end_src

**** Edit region in indirect buffer

To be able to edit source code blocks in markdown buffers just like it's done
in org-mode I use special package. It integrates with ~markdown-mode~
automatically and provides the way to edit source blocks by pressing =C-c '=.

#+begin_src emacs-lisp
(use-package edit-indirect)
#+end_src

*** XML

Built-in major mode for working with XML files. I need to set indentation to 4
spaces instead of 2 by default.

#+begin_src emacs-lisp
(use-package nxml-mode
  :ensure nil
  :config
  (setq nxml-child-indent 4
        nxml-attribute-indent 4))
#+end_src

**** Format XML

Third party package for reformatting XML documents. The command =xmlling=
should be available in the =PATH= (package name is =libxml2-utils=).

#+begin_src emacs-lisp
(use-package xml-format
  :demand t
  :after nxml-mode)
#+end_src

*** SSH config mode

Special mode to edit SSH configuration files.

#+begin_src emacs-lisp
(use-package ssh-config-mode
  :config
  (add-to-list 'auto-mode-alist '("/\\.ssh/config\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/system/ssh\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/sshd?_config\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/known_hosts\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/authorized_keys2?\\'" . ssh-config-mode))
  (add-hook 'ssh-config-mode-hook #'turn-on-font-lock)
  (autoload 'ssh-config-mode "ssh-config-mode" t))
#+end_src

*** Nginx

Syntax highlighting for nginx configuration files.

#+begin_src emacs-lisp
(use-package nginx-mode)
#+end_src

*** CSV

Major mode for work with CSV files.

#+begin_src emacs-lisp
(use-package csv-mode)
#+end_src

*** Log files

I used to use this nice mode to work with log files. Now logs mostly moved to
JSON format and stored in elastic search database and can be viewed in
Kibana. I find old way for convenient, so I keep this settings so far.

Log files can be quite large, so I use =logview= along with built-in =vlf=
package.

#+begin_src emacs-lisp
(use-package vlf
  :config
  (require 'vlf-setup))

(use-package logview
  :config
  (setq logview-additional-level-mappings
        '(("Python" . ((error       "CRITICAL")
                       (error       "ERROR")
                       (warning     "WARNING")
                       (information "INFO")
                       (debug       "DEBUG")))))

  (setq logview-additional-submodes
        '(("Python" (format . "TIMESTAMP LEVEL - [NAME]:") (levels . "Python")))))
#+end_src

*** PKGBUILD major mode

Edit =PKGBUILD= files for Arch Linux.

#+begin_src emacs-lisp
(use-package pkgbuild-mode
  :config
  (add-to-list 'auto-mode-alist '("/PKGBUILD$" . pkgbuild-mode)))
#+end_src

*** SQL

To perform SQL queries I use =org-mode= and =ob-sql=. Emacs has built-in
facilities to connect to databases and perform as SQL client through
=comint-mode=.

**** COMMENT Emacs clojure database client

I used to use this package. It's quite good but requires CIDER as dependency
and I found it a bit too heavy for such kind of things. If you need to analyze
results of queries it separate buffers you probably should take a look at this
package.

Now it's not enabled in my config and probably will be removed in future.

#+begin_src emacs-lisp
(use-package ejc-sql
  :config
  (defun rr/ejc-sql-connected-hook ()
    (ejc-set-rows-limit 500)
    (ejc-set-column-width-limit nil))

  (add-hook 'ejc-sql-connected-hook #'rr/ejc-sql-connected-hook)

  (setq ejc-org-mode-show-results nil)

  (add-hook 'ejc-sql-minor-mode-hook
            (lambda ()
              (auto-complete-mode t)
              (ejc-ac-setup)))

  ;; Define connections
  (when (require 'databases nil t)
    (rr/setup-connections)))
#+end_src

**** Tweaks for sql-mode and sql-indent package

Better indentation support for =sql-mode= buffers.

#+begin_src emacs-lisp
(use-package sql-indent
  :config
  (setq sql-use-indent-support t)
  (add-hook 'sql-mode-hook #'sqlind-minor-mode))
#+end_src

**** Make PostgreSQL default

I use mostly PostgreSQL so I set this engine by default.

#+begin_src emacs-lisp
(eval-after-load "sql"
  '(progn
     (sql-set-product 'postgres)))
#+end_src

**** Disable line breaking

Fix broken tables for results of SQL queries.

#+begin_src emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda () (setq truncate-lines t)))
#+end_src

*** Shell

Nothing special, just add company backend for company mode to complete
environment variables, binaries found on your =$PATH= and fish shell functions.

#+begin_src emacs-lisp
(use-package company-shell
  :config
  (add-to-list 'company-backends #'company-shell))
#+end_src

*** Java

Java development in emacs is still quite painful. LSP mode is pretty good but
if you work in the team where everybody uses Intellij IDEA there are some
inconsistency (code formatting, code linting). I use [[https://github.com/google/google-java-format][google-java-format]] for
automatic code reformat and set default indentation to 2 spaces.

#+begin_src emacs-lisp
(use-package google-java-format
  :after cc-mode
  :ensure nil
  :config
  (setq google-java-format-executable (expand-file-name "~/.local/bin/google-java-format"))

  (defun rr/java-format-and-save ()
    (interactive)
    (google-java-format-buffer)
    (save-buffer))

  (define-key java-mode-map (kbd "C-c C-f") #'rr/java-format-and-save))

(use-package cc-vars
  :after cc-mode
  :ensure nil
  :config
  (add-hook 'java-mode-hook
            (lambda ()
              (setq c-basic-offset 2))))
#+end_src

**** lsp-java

LSP mode support for java distributed as a separate package and exposes some
extra settings.

#+begin_src emacs-lisp
(use-package lsp-java
  :after lsp-mode
  :config
  (add-hook 'java-mode-hook #'lsp)
  (setq lsp-java-save-actions-organize-imports nil
        lsp-java-format-enabled nil
        lsp-java-format-on-type-enabled nil
        lsp-java-code-generation-use-blocks t
        lsp-java-maven-download-sources t
        lsp-java-signature-help-enabled nil)

  (setq lsp-java-format-settings-url "file:///home/rrudakov/Work/EPAM/eclipse-java-code-style.xml"
        lsp-java-format-settings-profile "GoogleStyle")

  (setq lsp-java-vmargs '("-javaagent:/home/rrudakov/Soft/lombok/lombok.jar"
                          "-noverify"
                          "-Xmx2G"
                          "-XX:+UseG1GC"
                          "-XX:+UseStringDeduplication")))
#+end_src

*** Clojure

JVM based LISP. One of my favorite languages.

**** Clojure kondo linter

Static code analyzer [[https://github.com/borkdude/clj-kondo][clj-kondo]]. Works well together with CIDER and helps to fix
a lot of common issues in clojure code.

No needs any special configuration.

#+begin_src emacs-lisp
(use-package flycheck-clj-kondo)
#+end_src

**** Clojure mode

Major mode for Clojure and ClojureScript source files. Syntax highlighting and
many useful commands. See full list of them [[https://github.com/clojure-emacs/clojure-mode/#refactoring-support][here]].

#+begin_src emacs-lisp
(use-package clojure-mode
  :after flycheck-clj-kondo
  :config
  (require 'flycheck-clj-kondo))
#+end_src

**** CIDER

Clojure Interactive Development Environment which Rocks :)

Very nice IDE. Works good out of the box with clojure. For clojure script I
found it not perfect, but alternatives even worse.

#+begin_src emacs-lisp
(use-package cider
  :config
  (setq cider-prompt-for-symbol nil
        cider-repl-wrap-history t
        nrepl-hide-special-buffers t
        cider-repl-display-help-banner nil)
  (add-hook 'clojure-mode-hook #'cider-mode)
  (add-hook 'clojurescript-mode-hook #'cider-mode))
#+end_src

**** Clojure refactoring

Nice addition to CIDER. Introduce a lot of useful interactive functions to
interact with =refactoring-nrepl=.

#+begin_src emacs-lisp
(use-package clj-refactor
  :config
  (defun my-clojure-mode-hook ()
    (clj-refactor-mode 1))

  (setq cljr-hotload-dependencies t
        cljr-warn-on-eval nil)
  (add-hook 'clojure-mode-hook #'my-clojure-mode-hook)
  (add-hook 'clojurescript-mode-hook #'my-clojure-mode-hook))
#+end_src

***** Clojure refactoring helm integration

Helm interface for =clj-refactor= package.

#+begin_src emacs-lisp
(use-package cljr-helm
  :after clj-refactor
  :config
  (define-key clojure-mode-map (kbd "C-c C-r") #'cljr-helm)
  (define-key clojurescript-mode-map (kbd "C-c C-r") #'cljr-helm))
#+end_src

**** CIDER helm integration

#+begin_src emacs-lisp
(use-package helm-cider
  :config
  (helm-cider-mode 1))
#+end_src

*** JavaScript

**** Prettier

Format JavaScript and TypeScript code. Also has support for another languages
(HTML, YAML). Full list can be found on [[https://prettier.io/docs/en/index.html][Prettier page]].

I don't use =prettier-js-mode= (sometimes after =tide= refactoring commands it
goes crazy) and prefer to format code manually.

#+begin_src emacs-lisp
(use-package prettier-js
  :config
  (setq prettier-js-args '("--single-quote")
        prettier-js-show-errors nil))
#+end_src

**** Add node_modules to path

When open file from any kind of JS project, add =node_modules= to =PATH=
variable. It makes some project local binaries (tsserver, eslint) available.

#+begin_src emacs-lisp
(use-package add-node-modules-path
  :config
  (eval-after-load 'js-mode
    '(add-hook 'js-mode-hook #'add-node-modules-path))

  (eval-after-load 'typescript-mode
    '(add-hook 'typescript-mode-hook #'add-node-modules-path))

  (eval-after-load 'web-mode
    '(add-hook 'web-mode-hook #'add-node-modules-path)))
#+end_src

**** TypeScript

So far =tide= is the best option for me for working with TypeScript
projects. Comparing with =lsp-mode= it's faster, because interacts directly
with =tsserver=.

I have keybindings similar to my =lsp-mode= bindings.

#+begin_src emacs-lisp
(use-package typescript-mode
  :config
  (setq typescript-indent-level 2))

(use-package tide
  :after prettier-js
  :config

  (defun setup-tide-mode ()
    "Bunch of settings for `tide-mode'."
    (interactive)
    (tide-setup)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (tide-hl-identifier-mode +1))

  (defun rr/tide-clean-imports-and-reformat ()
    "Run two commands sequentially `tide-organize-imports' and `prettier-js'."
    (interactive)
    (save-excursion
      (tide-organize-imports)
      (prettier-js)
      (save-buffer)))

  ;; aligns annotation to the right hand side
  (setq tide-sort-completions-by-kind t
        tide-completion-detailed t
        tide-completion-show-source t)

  (add-hook 'typescript-mode-hook #'setup-tide-mode)
  (setq tide-format-options '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil))

  (define-key tide-mode-map (kbd "C-c j a") #'tide-fix)
  (define-key tide-mode-map (kbd "C-c C-f") #'rr/tide-clean-imports-and-reformat)
  (define-key tide-mode-map (kbd "C-c j r") #'tide-rename-symbol)

  (flycheck-add-next-checker 'tsx-tide 'javascript-eslint 'append)
  (flycheck-add-next-checker 'typescript-tide 'javascript-eslint 'append)
  (flycheck-add-next-checker 'jsx-tide 'javascript-eslint 'append)
  (flycheck-add-next-checker 'javascript-tide 'javascript-eslint 'append))
#+end_src

**** COMMENT JSX-mode

Since version 27.1 emacs has built-in support for JSX syntax.

#+begin_src emacs-lisp
(use-package js
  :ensure nil
  :config
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . js-jsx-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js-jsx-mode))
  (add-hook 'js-jsx-mode-hook #'setup-tide-mode)
  (flycheck-add-mode 'javascript-eslint 'js-jsx-mode))
#+end_src

**** COMMENT Angular support

Used to use it on one of my jobs. Probably will remove this configuration in
future.

#+begin_src emacs-lisp
(use-package ng2-mode
  :after tide
  :config
  (require 'ng2-mode)
  (require 'flycheck)
  (require 'tide)
  (flycheck-add-mode 'typescript-tide 'ng2-ts-mode)
  (add-to-list 'auto-mode-alist '("\\.component.html" . ng2-html-mode)))
#+end_src

*** Web-mode

Super powerful major mode for editing *web templates*. Support various template
engines, embedded CSS and JavaScript.

#+begin_src emacs-lisp
(use-package web-mode
  :config
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-enable-auto-closing t
        web-mode-enable-auto-pairing nil
        web-mode-enable-auto-quoting nil
        web-mode-enable-auto-opening t
        web-mode-enable-css-colorization t)

  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jinja2\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))

  ;; Set django engine for django projects
  (defun rr/django-project-hook ()
    (if (projectile-project-p)
        (if (file-exists-p (concat (projectile-project-root) "manage.py"))
            (web-mode-set-engine "django"))))

  (add-hook 'web-mode-hook #'rr/django-project-hook)
  (add-hook 'web-mode-hook
            (lambda ()
              (when (string-equal "tsx" (file-name-extension buffer-file-name))
                (setup-tide-mode))))
  (flycheck-add-mode 'javascript-eslint 'web-mode)

  (add-hook 'web-mode-hook
            (lambda ()
              (when (string-equal "jsx" (file-name-extension buffer-file-name))
                (setup-tide-mode))))
  (flycheck-add-mode 'javascript-eslint 'web-mode))
#+end_src

**** COMMENT Company-web

#+begin_src emacs-lisp
(use-package company-web
  :config
  (add-to-list 'company-backends #'company-web-html)
  (add-to-list 'company-backends #'company-web-jade)
  (add-to-list 'company-backends #'company-web-slim))
#+end_src

*** Rust

I use =lsp-mode= for RUST. Here I just explicitly add =rust-mode= support.

#+begin_src emacs-lisp
(use-package rust-mode)
#+end_src

*** Python

**** Virtualenv

#+begin_src emacs-lisp
(use-package pyvenv
  :config
  (add-hook 'python-mode-hook 'pyvenv-tracking-mode)
  (add-hook 'pyvenv-post-activate-hooks #'lsp))
#+end_src

**** Default interpreter

#+begin_src emacs-lisp
(use-package python
  :ensure nil
  :config
  (setq python-shell-interpreter "python3"))
#+end_src

**** Automatically sort imports

#+begin_src emacs-lisp
(use-package isortify
  :config
  (setq isortify-line-width 79
        isortify-multi-line-output 3
        isortify-trailing-comma t)
  (add-hook 'python-mode-hook #'isortify-mode))
#+end_src

**** Format code

#+begin_src emacs-lisp
(use-package blacken
  :config
  (setq blacken-line-length 79
        blacken-allow-py36 nil))

(use-package py-yapf)
#+end_src

**** Tox

#+begin_src emacs-lisp
(use-package tox
  :config
  (setq tox-runner 'py.test))
#+end_src

**** Sphinx doc

#+begin_src emacs-lisp
(use-package sphinx-doc
  :config
  (add-hook 'python-mode-hook #'sphinx-doc-mode))
#+end_src

**** Editing requirements files

#+begin_src emacs-lisp
(use-package pip-requirements)
#+end_src

*** LaTeX

**** AucTEX tweaks

#+begin_src emacs-lisp
(use-package tex
  :ensure nil
  :config
  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  (setq-default TeX-master nil))

(use-package font-latex
  :ensure nil
  :config
  (setq font-latex-fontify-sectioning 'color))

(use-package latex
  :ensure nil
  :config
  (eval-after-load 'latex
    '(add-to-list 'LaTeX-verbatim-environments "lstlisting"))
  (add-hook 'LaTeX-mode-hook #'visual-line-mode)
  (add-hook 'LaTeX-mode-hook #'flyspell-mode)
  (add-hook 'LaTeX-mode-hook #'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook #'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook (lambda () (auto-fill-mode -1)))
  (add-hook 'LaTeX-mode-hook (lambda () (TeX-fold-mode 1))))
#+end_src

**** Company AucTEX

#+begin_src emacs-lisp
(use-package company-auctex
  :config
  (company-auctex-init))
#+end_src

*** Haskell

**** Haskell mode

#+begin_src emacs-lisp
(use-package haskell-mode
  :config
  (setq haskell-mode-stylish-haskell-path "brittany")
  (setq haskell-stylish-on-save nil)

  (add-hook 'haskell-mode-hook #'haskell-auto-insert-module-template)
  (add-hook 'haskell-mode-hook #'turn-on-haskell-doc-mode))
#+end_src

**** lsp-haskell

#+begin_src emacs-lisp
(use-package lsp-haskell
  :config
  (add-hook 'haskell-mode-hook #'lsp))
#+end_src

**** Align rules

#+begin_src emacs-lisp
(add-hook 'align-load-hook
          (lambda ()
            (add-to-list 'align-rules-list
                         '(haskell-types
                           (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                           (modes quote (haskell-mode literate-haskell-mode))))))
(add-hook 'align-load-hook
          (lambda ()
            (add-to-list 'align-rules-list
                         '(haskell-assignment
                           (regexp . "\\(\\s-+\\)=\\s-+")
                           (modes quote (haskell-mode literate-haskell-mode))))))

(add-hook 'align-load-hook
          (lambda ()
            (add-to-list 'align-rules-list
                         '(haskell-arrows
                           (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                           (modes quote (haskell-mode literate-haskell-mode))))))

(add-hook 'align-load-hook
          (lambda ()
            (add-to-list 'align-rules-list
                         '(haskell-left-arrows
                           (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                           (modes quote (haskell-mode literate-haskell-mode))))))
#+end_src

**** Indentation

#+begin_src emacs-lisp
(use-package hindent
  :config
  (add-hook 'haskell-mode-hook #'hindent-mode))
#+end_src

**** Stack interface

#+begin_src emacs-lisp
(use-package hasky-stack
  :config
  (global-set-key (kbd "C-c h e") #'hasky-stack-execute)
  (global-set-key (kbd "C-c h h") #'hasky-stack-package-action)
  (global-set-key (kbd "C-c h i") #'hasky-stack-new))
#+end_src

**** Ligatures support

#+begin_src emacs-lisp
(use-package hasklig-mode
  :config
  (add-hook 'haskell-mode-hook 'hasklig-mode))
#+end_src

*** JSON

#+begin_src emacs-lisp
(use-package json-mode
  :config
  (setq json-reformat:indent-width 4
        json-reformat:pretty-string? t)
  (add-hook 'json-mode-hook #'flycheck-mode))
#+end_src

*** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-mode)))
#+end_src

*** Groovy

#+begin_src emacs-lisp
(use-package groovy-mode)
#+end_src

*** Gherkin

#+begin_src emacs-lisp
(use-package feature-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.story$" . feature-mode)))
#+end_src

*** PlantUML

#+begin_src emacs-lisp
(use-package plantuml-mode
  :config
  (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar"
        plantuml-default-exec-mode 'executable)
  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml)))
#+end_src

*** Protobuf

#+begin_src emacs-lisp
(use-package protobuf-mode)
#+end_src

* Email

** Setup username and email address

#+begin_src emacs-lisp
(setq user-mail-address "rrudakov@pm.me"
      user-full-name "Roman Rudakov")
#+end_src

** ProtonMail configuration

#+begin_src emacs-lisp
(use-package mu4e
  :ensure nil
  :after message
  :config
  (define-key mu4e-main-mode-map [remap mu4e-quit] #'kill-current-buffer)
  (global-set-key (kbd "C-c e") #'mu4e)
  (setq mu4e-maildir (expand-file-name "~/.mail/ProtonMail")
        mu4e-compose-reply-to-address user-mail-address
        mu4e-sent-folder "/Sent"
        mu4e-trash-folder "/Trash"
        mu4e-drafts-folder "/Drafts"
        mu4e-sent-messages-behavior 'delete
        mu4e-view-use-gnus nil
        mu4e-hide-index-messages t
        mu4e-headers-auto-update t
        mu4e-compose-signature "Best regards.\n\nRoman Rudakov."
        mu4e-compose-signature-auto-include t
        mu4e-compose-dont-reply-to-self t
        mu4e-completing-read-function 'completing-read
        mu4e-maildir-shortcuts '(("/INBOX" . ?i)
                                 ("/Sent" . ?s)
                                 ("/Trash" . ?t)
                                 ("/All Mail" . ?a))
        mu4e-use-fancy-chars nil
        mu4e-view-show-images t
        mu4e-view-prefer-html nil
        ;; mu4e-html2text-command "w3m -dump -T text/html -O utf8 -graph"
        mu4e-headers-fields '((:human-date . 25)
                              (:flags . 6)
                              (:from . 22)
                              (:subject . nil))
        message-kill-buffer-on-exit t
        mu4e-split-view 'single-window
        mail-user-agent 'mu4e-user-agent)

  (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

  ;; Run mu4e in background after starting emacs
  (mu4e t))
#+end_src

** Use helm for mail filtration

#+begin_src emacs-lisp
(use-package helm-mu
  :after (helm mu4e)
  :config
  (define-key mu4e-main-mode-map (kbd "s") #'helm-mu)
  (define-key mu4e-headers-mode-map (kbd "s") #'helm-mu)
  (define-key mu4e-view-mode-map (kbd "s") #'helm-mu))
#+end_src

** Alerts

#+begin_src emacs-lisp
(use-package mu4e-alert
  :config
  (setq mu4e-alert-modeline-formatter (lambda (count)
                                        (if (> count 0)
                                            (format "[Unread emails: %d]" count)
                                          "")))
  (mu4e-alert-set-default-style 'libnotify)
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src

** Sending emails

#+begin_src emacs-lisp
(use-package smtpmail
  :ensure nil
  :after message
  :config
  (setq message-send-mail-function #'smtpmail-send-it
        smtpmail-smtp-server "127.0.0.1"
        smtpmail-smtp-service 1025
        smtpmail-stream-type 'starttls))
#+end_src

** GNUS

GNUS split into many packages. I use ~use-package~ to setup each of them.

First setup groups and IMAP.

#+begin_src emacs-lisp
(use-package gnus
  :config
  (setq gnus-select-method '(nntp "news.gwene.org"))
  (setq gnus-secondary-select-methods
        '((nnimap "protonmail"
                  (nnimap-address "127.0.0.1")
                  (nnimap-server-port 1143)
                  (nnimap-stream starttls))))
  (setq gnus-agent t
        gnus-novice-user t
        gnus-use-cache t))
#+end_src

Do not save ~.newsrc~ file. I don't use another newsreaders.

#+begin_src emacs-lisp
(use-package gnus-start
  :ensure gnus
  :config
  (setq gnus-save-newsrc-file nil))
#+end_src

Setup groups view.

#+begin_src emacs-lisp
(use-package gnus-group
  :ensure gnus
  :config
  (setq gnus-group-mode-line-format "%%b"
        gnus-list-groups-with-ticked-articles nil
        gnus-group-sort-function
        '((gnus-group-sort-by-unread)
          (gnus-group-sort-by-alphabet)
          (gnus-group-sort-by-rank))))
#+end_src

Enable topics by default in groups view.

#+begin_src emacs-lisp
(use-package gnus-topic
  :ensure gnus
  :config
  (setq gnus-topic-display-empty-topics t)
  (add-hook 'gnus-group-mode-hook 'gnus-topic-mode))
#+end_src

Prettify summary view. Setup mode line and continuations arrow for threads.

#+begin_src emacs-lisp
(use-package gnus-sum
  :ensure gnus
  :demand t
  :config
  (setq gnus-auto-select-first nil
        gnus-summary-mode-line-format "%p"
        gnus-fetch-old-headers 'some)
  (setq gnus-user-date-format-alist
        '(((gnus-seconds-today) . "Today at %R")
          ((+ 86400 (gnus-seconds-today)) . "Yesterday, %R")
          (t . "%Y-%m-%d %R")))
  (setq gnus-summary-line-format "%U%R%z %-16,16&user-date;  %4L:%-30,30f  %B%S\n")
  (setq gnus-sum-thread-tree-false-root ""
        gnus-sum-thread-tree-indent " "
        gnus-sum-thread-tree-leaf-with-other "├─➤ "
        gnus-sum-thread-tree-root ""
        gnus-sum-thread-tree-single-leaf "└─➤ "
        gnus-sum-thread-tree-vertical "│")

  (add-hook 'gnus-summary-mode #'hl-line-mode))
#+end_src

Enable asynchronous operations in GNUS.

#+begin_src emacs-lisp
(use-package gnus-async
  :ensure nil
  :config
  (setq gnus-asynchronous t))
#+end_src

Prefer plain text over HTML (not sure if it is actually works):

#+begin_src emacs-lisp
(use-package mm-decode
  :ensure nil
  :config
  (with-eval-after-load "mm-decode"
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text/richtext")))
#+end_src

Enable demon on GNUS startup to check new mail periodically.

#+begin_src emacs-lisp
(use-package gnus-demon
  :ensure gnus
  :config
  (add-hook 'gnus-startup-hook
            (lambda ()
              (gnus-demon-add-handler #'gnus-demon-scan-news 5 nil)
              (gnus-demon-init))))
#+end_src

Enable notifications when new email/news is received:

#+begin_src emacs-lisp
(use-package gnus-notifications
  :ensure gnus
  :config
  (setq gnus-notifications-use-google-contacts nil)
  (add-hook 'gnus-after-getting-new-news-hook 'gnus-notifications))
#+end_src

* IRC Client for emacs (ERC)

This is built-in package. I'm trying to use it for gitter. It's in testing, not
sure if I'll keep this settings in my config.

#+begin_src emacs-lisp
(use-package erc
  :ensure nil
  :config
  (setq erc-server "irc.gitter.im"
        erc-port 6667
        erc-prompt-for-password nil))

(use-package erc-join
  :ensure nil
  :config
  (setq erc-autojoin-channels-alist
        '(("irc.gitter.im" "#emacs-lsp/lsp-mode"))))
#+end_src

* Elfeed

Elfeed is and extensible web feed reader for Emacs, supporting both Atom and
RSS.

#+begin_src emacs-lisp
(use-package elfeed
  :config
  (setq-default elfeed-search-filter "@1-week-ago +unread ")
  (setq elfeed-feeds
        '(("https://updates.orgmode.org/feed/updates" org)
          ("https://www.reddit.com/r/emacs.rss" reddit emacs)))
  (global-set-key (kbd "C-x w") 'elfeed))
#+end_src

* REST client

Very powerful and at the same time simple package. It replaced Postman for me.

#+begin_src emacs-lisp
(use-package restclient)
#+end_src

And completion backend for it:

#+begin_src emacs-lisp
(use-package company-restclient
  :config
  (add-to-list 'company-backends #'company-restclient))
#+end_src

And even org-babel integration:

#+begin_src emacs-lisp
(use-package ob-restclient
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t))))
#+end_src

* PDF tools

View and navigate PDF file inside emacs.

#+begin_src emacs-lisp
(use-package pdf-tools
  :config
  (pdf-tools-install))
#+end_src

* Htmlize

#+begin_src emacs-lisp
(use-package htmlize
  :config
  (setq org-html-htmlize-output-type 'inline-css))
#+end_src

* Password store

#+begin_src emacs-lisp
(use-package password-store
  :config
  (setq password-store-password-length 12))

(use-package password-store-otp)

(use-package pass)

(use-package helm-pass)
;; (use-package ivy-pass)
#+end_src

* Google translate interface

#+begin_src emacs-lisp
(use-package google-translate-smooth-ui
  :ensure google-translate
  :config
  (setq google-translate-pop-up-buffer-set-focus t
        google-translate-translation-directions-alist
        '(("en" . "ru")
          ("ru" . "en")
          ("nl" . "en")
          ("en" . "nl")))
  (global-set-key (kbd "C-c t") 'google-translate-smooth-translate))
#+end_src

* Kubernetes

** Major mode for kubernetes config files

#+begin_src emacs-lisp
(use-package k8s-mode
 :config
 (setq k8s-search-documentation-browser-function 'browse-url-firefox)
 (add-hook 'k8s-mode-hook #'yas-minor-mode))
#+end_src

** Kubernetes client for emacs

#+begin_src emacs-lisp
(use-package kubernetes
  :commands (kubernetes-overview))
#+end_src

* Dockerfile mode

#+begin_src emacs-lisp
(use-package dockerfile-mode)
#+end_src

* Emacs everywhere

#+begin_src emacs-lisp
(defun pull-request-conversation-p (window-title)
  "Predicate to make sure WINDOW-TITLE match PR conversation."
  (or (string-match-p "Pull Request" window-title)))

(defun jira-ticket-p (window-title)
  "Predicate to make sure WINDOW-TITLE match JIRA ticket creation page."
  (or (string-match-p "Create issue" window-title)))

(defun popup-handler (app-name window-title x y w h)
  "Set major mode based on APP-NAME and WINDOW-TITLE."
  (cond
   ((pull-request-conversation-p window-title) (gfm-mode))
   ((jira-ticket-p window-title) (progn
                                   (org-mode)
                                   (add-hook 'delete-frame-functions #'rr/replace-org-with-jira-markup -100 t)))
   (t (markdown-mode)))
  ;; (when (gui-get-selection 'PRIMARY)
  ;;   (insert (gui-get-selection 'PRIMARY)))
  )

(add-hook 'ea-popup-hook 'popup-handler)
#+end_src

* Create GIF screencasts

#+begin_src emacs-lisp
(use-package gif-screencast)
#+end_src

* Funny

** Speed type

#+begin_src emacs-lisp
(use-package speed-type)
#+end_src

** Literate calc mode

#+begin_src emacs-lisp
(use-package literate-calc-mode)
#+end_src

* Set keybindings

I set the most important global keybindings at the end of my configuration in
case I used the same key already somewhere earlier. This bindings will
overwrite previous if they exist.

** Common

#+begin_src emacs-lisp
(global-set-key (kbd "M-[") #'align)
(global-set-key (kbd "<f6>") #'profiler-start)
(global-set-key (kbd "<f7>") #'profiler-report)
(global-set-key (kbd "<f8>") #'profiler-stop)
#+end_src

** Org

Global =org-mode= invocation commands.

#+begin_src emacs-lisp
(global-set-key (kbd "C-c l") #'org-store-link)
(global-set-key (kbd "C-c a") #'org-agenda)
(global-set-key (kbd "C-c c") #'org-capture)
(global-set-key (kbd "C-c b") #'org-switchb)
(global-set-key (kbd "<f5>") #'org-clock-goto)
#+end_src
